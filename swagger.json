{
  "swagger": "2.0",
  "info": {
    "title": "Kruise",
    "version": "v1.4.0"
  },
  "paths": {
    "/apis/apps.kruise.io/v1beta1/statefulsets": {
      "get": {
        "description": "list objects of kind StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "listStatefulSetForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/uniteddeployments": {
      "get": {
        "description": "list objects of kind UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedUnitedDeployment",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeploymentList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create an UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedUnitedDeployment",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedUnitedDeployment",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/containerrecreaterequests/{name}/status": {
      "get": {
        "description": "read status of the specified ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedContainerRecreateRequestStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedContainerRecreateRequestStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified ContainerRecreateRequest",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedContainerRecreateRequestStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ContainerRecreateRequest",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/statefulsets/{name}/scale": {
      "get": {
        "description": "read scale of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedStatefulSetScale",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace scale of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedStatefulSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update scale of the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedStatefulSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/resourcedistributions": {
      "get": {
        "description": "list objects of kind ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listResourceDistribution",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistributionList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createResourceDistribution",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionResourceDistribution",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/resourcedistributions/{name}/status": {
      "get": {
        "description": "read status of the specified ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readResourceDistributionStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceResourceDistributionStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified ResourceDistribution",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchResourceDistributionStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ResourceDistribution",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/persistentpodstates": {
      "get": {
        "description": "list objects of kind PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedPersistentPodState",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodStateList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedPersistentPodState",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedPersistentPodState",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/persistentpodstates/{name}/status": {
      "get": {
        "description": "read status of the specified PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedPersistentPodStateStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedPersistentPodStateStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified PersistentPodState",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedPersistentPodStateStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PersistentPodState",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/broadcastjobs/{name}/status": {
      "get": {
        "description": "read status of the specified BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedBroadcastJobStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedBroadcastJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified BroadcastJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedBroadcastJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the BroadcastJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/ephemeraljobs": {
      "get": {
        "description": "list objects of kind EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listEphemeralJobForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/uniteddeployments/{name}": {
      "get": {
        "description": "read the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedUnitedDeployment",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedUnitedDeployment",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete an UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedUnitedDeployment",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified UnitedDeployment",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedUnitedDeployment",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the UnitedDeployment",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagepulljobs": {
      "get": {
        "description": "list objects of kind ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedImagePullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create an ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedImagePullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedImagePullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/persistentpodstates": {
      "get": {
        "description": "list objects of kind PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listPersistentPodStateForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodStateList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/workloadspreads": {
      "get": {
        "description": "list objects of kind WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedWorkloadSpread",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpreadList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedWorkloadSpread",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedWorkloadSpread",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/ephemeraljobs": {
      "get": {
        "description": "list objects of kind EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedEphemeralJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create an EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedEphemeralJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedEphemeralJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/daemonsets": {
      "get": {
        "description": "list objects of kind DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedDaemonSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedDaemonSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedDaemonSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagepulljobs/{name}": {
      "get": {
        "description": "read the specified ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedImagePullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedImagePullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete an ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedImagePullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified ImagePullJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedImagePullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ImagePullJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/advancedcronjobs/{name}": {
      "get": {
        "description": "read the specified AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedAdvancedCronJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedAdvancedCronJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete an AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedAdvancedCronJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified AdvancedCronJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedAdvancedCronJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the AdvancedCronJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/sidecarsets/{name}/status": {
      "get": {
        "description": "read status of the specified SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readSidecarSetStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceSidecarSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified SidecarSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchSidecarSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SidecarSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/daemonsets/{name}": {
      "get": {
        "description": "read the specified DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedDaemonSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedDaemonSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedDaemonSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified DaemonSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedDaemonSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the DaemonSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1beta1/namespaces/{namespace}/statefulsets/{name}": {
      "get": {
        "description": "read the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "readNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "replaceNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "deleteNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "patchNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodepodprobes": {
      "get": {
        "description": "list objects of kind NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNodePodProbe",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbeList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNodePodProbe",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNodePodProbe",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1beta1/namespaces/{namespace}/statefulsets": {
      "get": {
        "description": "list objects of kind StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "listNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "createNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "deleteCollectionNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/sidecarsets/{name}": {
      "get": {
        "description": "read the specified SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readSidecarSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceSidecarSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteSidecarSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified SidecarSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchSidecarSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SidecarSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/ephemeraljobs/{name}": {
      "get": {
        "description": "read the specified EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedEphemeralJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedEphemeralJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete an EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedEphemeralJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified EphemeralJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedEphemeralJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the EphemeralJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/workloadspreads/{name}/status": {
      "get": {
        "description": "read status of the specified WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedWorkloadSpreadStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedWorkloadSpreadStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified WorkloadSpread",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedWorkloadSpreadStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the WorkloadSpread",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/containerrecreaterequests/{name}": {
      "get": {
        "description": "read the specified ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified ContainerRecreateRequest",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ContainerRecreateRequest",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodeimages": {
      "get": {
        "description": "list objects of kind NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNodeImage",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImageList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNodeImage",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNodeImage",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/clonesets/{name}": {
      "get": {
        "description": "read the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedCloneSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedCloneSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedCloneSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified CloneSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedCloneSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the CloneSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/workloadspreads/{name}": {
      "get": {
        "description": "read the specified WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedWorkloadSpread",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedWorkloadSpread",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedWorkloadSpread",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified WorkloadSpread",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedWorkloadSpread",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpread"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the WorkloadSpread",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/imagepulljobs": {
      "get": {
        "description": "list objects of kind ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listImagePullJobForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/podprobemarkers/{name}": {
      "get": {
        "description": "read the specified PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedPodProbeMarker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedPodProbeMarker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedPodProbeMarker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified PodProbeMarker",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedPodProbeMarker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PodProbeMarker",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodepodprobes/{name}/status": {
      "get": {
        "description": "read status of the specified NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNodePodProbeStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNodePodProbeStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified NodePodProbe",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNodePodProbeStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the NodePodProbe",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/broadcastjobs/{name}": {
      "get": {
        "description": "read the specified BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedBroadcastJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedBroadcastJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedBroadcastJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified BroadcastJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedBroadcastJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the BroadcastJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/podprobemarkers": {
      "get": {
        "description": "list objects of kind PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedPodProbeMarker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarkerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedPodProbeMarker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedPodProbeMarker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/persistentpodstates/{name}": {
      "get": {
        "description": "read the specified PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedPersistentPodState",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedPersistentPodState",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a PersistentPodState",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedPersistentPodState",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified PersistentPodState",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedPersistentPodState",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PersistentPodState"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PersistentPodState",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/clonesets": {
      "get": {
        "description": "list objects of kind CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listCloneSetForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/advancedcronjobs": {
      "get": {
        "description": "list objects of kind AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedAdvancedCronJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create an AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedAdvancedCronJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedAdvancedCronJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagepulljobs/{name}/status": {
      "get": {
        "description": "read status of the specified ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedImagePullJobStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified ImagePullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedImagePullJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified ImagePullJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedImagePullJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImagePullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ImagePullJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/workloadspreads": {
      "get": {
        "description": "list objects of kind WorkloadSpread",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listWorkloadSpreadForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.WorkloadSpreadList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/podprobemarkers": {
      "get": {
        "description": "list objects of kind PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listPodProbeMarkerForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarkerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagelistpulljobs/{name}": {
      "get": {
        "description": "read the specified ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedImageListPullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedImageListPullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete an ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedImageListPullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified ImageListPullJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedImageListPullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ImageListPullJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/statefulsets/{name}/status": {
      "get": {
        "description": "read status of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedStatefulSetStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedStatefulSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedStatefulSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/uniteddeployments/{name}/status": {
      "get": {
        "description": "read status of the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedUnitedDeploymentStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedUnitedDeploymentStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified UnitedDeployment",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedUnitedDeploymentStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeployment"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the UnitedDeployment",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/advancedcronjobs": {
      "get": {
        "description": "list objects of kind AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listAdvancedCronJobForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/broadcastjobs": {
      "get": {
        "description": "list objects of kind BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedBroadcastJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedBroadcastJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedBroadcastJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/podprobemarkers/{name}/status": {
      "get": {
        "description": "read status of the specified PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedPodProbeMarkerStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified PodProbeMarker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedPodProbeMarkerStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified PodProbeMarker",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedPodProbeMarkerStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.PodProbeMarker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PodProbeMarker",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1beta1/namespaces/{namespace}/statefulsets/{name}/status": {
      "get": {
        "description": "read status of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "readNamespacedStatefulSetStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace status of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "replaceNamespacedStatefulSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "patchNamespacedStatefulSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1beta1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/containerrecreaterequests": {
      "get": {
        "description": "list objects of kind ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequestList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedContainerRecreateRequest",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/uniteddeployments": {
      "get": {
        "description": "list objects of kind UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listUnitedDeploymentForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.UnitedDeploymentList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodepodprobes/{name}": {
      "get": {
        "description": "read the specified NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNodePodProbe",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNodePodProbe",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a NodePodProbe",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNodePodProbe",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified NodePodProbe",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNodePodProbe",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodePodProbe"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the NodePodProbe",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/clonesets": {
      "get": {
        "description": "list objects of kind CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedCloneSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedCloneSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedCloneSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/broadcastjobs": {
      "get": {
        "description": "list objects of kind BroadcastJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listBroadcastJobForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.BroadcastJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/daemonsets": {
      "get": {
        "description": "list objects of kind DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listDaemonSetForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/clonesets/{name}/status": {
      "get": {
        "description": "read status of the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedCloneSetStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedCloneSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified CloneSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedCloneSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.CloneSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the CloneSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagelistpulljobs": {
      "get": {
        "description": "list objects of kind ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedImageListPullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create an ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedImageListPullJob",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedImageListPullJob",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/uniteddeployments/{name}/scale": {
      "get": {
        "description": "read scale of the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedUnitedDeploymentScale",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace scale of the specified UnitedDeployment",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedUnitedDeploymentScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update scale of the specified UnitedDeployment",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedUnitedDeploymentScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the UnitedDeployment",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/advancedcronjobs/{name}/status": {
      "get": {
        "description": "read status of the specified AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedAdvancedCronJobStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified AdvancedCronJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedAdvancedCronJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified AdvancedCronJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedAdvancedCronJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the AdvancedCronJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/resourcedistributions/{name}": {
      "get": {
        "description": "read the specified ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readResourceDistribution",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceResourceDistribution",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a ResourceDistribution",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteResourceDistribution",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified ResourceDistribution",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchResourceDistribution",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ResourceDistribution"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ResourceDistribution",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/statefulsets": {
      "get": {
        "description": "list objects of kind StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listStatefulSetForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale": {
      "get": {
        "description": "read scale of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "readNamespacedStatefulSetScale",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace scale of the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "replaceNamespacedStatefulSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update scale of the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1beta1"
        ],
        "operationId": "patchNamespacedStatefulSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/sidecarsets": {
      "get": {
        "description": "list objects of kind SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listSidecarSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createSidecarSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.SidecarSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of SidecarSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionSidecarSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/daemonsets/{name}/status": {
      "get": {
        "description": "read status of the specified DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedDaemonSetStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified DaemonSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedDaemonSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified DaemonSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedDaemonSetStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.DaemonSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the DaemonSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/statefulsets": {
      "get": {
        "description": "list objects of kind StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSetList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "createNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete collection of StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteCollectionNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersionMatch",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/imagelistpulljobs": {
      "get": {
        "description": "list objects of kind ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listImageListPullJobForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJobList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/containerrecreaterequests": {
      "get": {
        "description": "list objects of kind ContainerRecreateRequest",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "listContainerRecreateRequestForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ContainerRecreateRequestList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
          "name": "resourceVersionMatch",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/ephemeraljobs/{name}/status": {
      "get": {
        "description": "read status of the specified EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedEphemeralJobStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified EphemeralJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedEphemeralJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified EphemeralJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedEphemeralJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.EphemeralJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the EphemeralJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodeimages/{name}": {
      "get": {
        "description": "read the specified NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNodeImage",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNodeImage",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNodeImage",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified NodeImage",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNodeImage",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the NodeImage",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/clonesets/{name}/scale": {
      "get": {
        "description": "read scale of the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedCloneSetScale",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace scale of the specified CloneSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedCloneSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update scale of the specified CloneSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedCloneSetScale",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.api.autoscaling.v1.Scale_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the CloneSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/statefulsets/{name}": {
      "get": {
        "description": "read the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedStatefulSet",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "description": "delete a StatefulSet",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "deleteNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update the specified StatefulSet",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedStatefulSet",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.StatefulSet"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the StatefulSet",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/nodeimages/{name}/status": {
      "get": {
        "description": "read status of the specified NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNodeImageStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified NodeImage",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNodeImageStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified NodeImage",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNodeImageStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.NodeImage"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the NodeImage",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/apps.kruise.io/v1alpha1/namespaces/{namespace}/imagelistpulljobs/{name}/status": {
      "get": {
        "description": "read status of the specified ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "readNamespacedImageListPullJobStatus",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace status of the specified ImageListPullJob",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "replaceNamespacedImageListPullJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "description": "partially update status of the specified ImageListPullJob",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "appsKruiseIo_v1alpha1"
        ],
        "operationId": "patchNamespacedImageListPullJobStatus",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1alpha1.ImageListPullJob"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        },
        "x-codegen-request-body-name": "body"
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ImageListPullJob",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    }
  },
  "definitions": {
    "v1alpha1.WorkloadSpreadList": {
      "description": "WorkloadSpreadList is a list of WorkloadSpread",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of workloadspreads. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.WorkloadSpread"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpreadList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1beta1.StatefulSetList": {
      "description": "StatefulSetList is a list of StatefulSet",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of statefulsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1beta1.StatefulSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "StatefulSetList",
          "version": "v1beta1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.NodePodProbeList": {
      "description": "NodePodProbeList is a list of NodePodProbe",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of nodepodprobes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.NodePodProbe"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "NodePodProbeList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.ImageListPullJob": {
      "description": "ImageListPullJob is the Schema for the imagelistpulljobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "ImageListPullJobSpec defines the desired state of ImageListPullJob",
          "type": "object",
          "required": [
            "completionPolicy",
            "images"
          ],
          "properties": {
            "completionPolicy": {
              "description": "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
              "type": "object",
              "properties": {
                "activeDeadlineSeconds": {
                  "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
                  "type": "integer",
                  "format": "int64"
                },
                "ttlSecondsAfterFinished": {
                  "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Only works for Always type",
                  "type": "integer",
                  "format": "int32"
                },
                "type": {
                  "description": "Type indicates the type of the CompletionPolicy. Default is Always.",
                  "type": "string"
                }
              }
            },
            "images": {
              "description": "Images is the image list to be pulled by the job",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "parallelism": {
              "description": "Parallelism is the requested parallelism, it can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.",
              "x-kubernetes-int-or-string": true
            },
            "podSelector": {
              "description": "PodSelector is a query over pods that should pull image on nodes of these pods. Mutually exclusive with Selector.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "pullPolicy": {
              "description": "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
              "type": "object",
              "properties": {
                "backoffLimit": {
                  "description": "Specifies the number of retries before marking the pulling task failed. Defaults to 3",
                  "type": "integer",
                  "format": "int32"
                },
                "timeoutSeconds": {
                  "description": "Specifies the timeout of the pulling task. Defaults to 600",
                  "type": "integer",
                  "format": "int32"
                }
              }
            },
            "pullSecrets": {
              "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "sandboxConfig": {
              "description": "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
              "type": "object",
              "properties": {
                "annotations": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "selector": {
              "description": "Selector is a query over nodes that should match the job. nil to match all nodes.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "names": {
                  "description": "Names specify a set of nodes to execute the job.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "description": "ImageListPullJobStatus defines the observed state of ImageListPullJob",
          "type": "object",
          "required": [
            "desired"
          ],
          "properties": {
            "active": {
              "description": "The number of running ImagePullJobs which are acknowledged by the imagepulljob controller.",
              "type": "integer",
              "format": "int32"
            },
            "completed": {
              "description": "The number of ImagePullJobs which are finished",
              "type": "integer",
              "format": "int32"
            },
            "completionTime": {
              "description": "Represents time when the all the image pull job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "desired": {
              "description": "The desired number of ImagePullJobs, this is typically equal to the number of len(spec.Images).",
              "type": "integer",
              "format": "int32"
            },
            "failedImageStatuses": {
              "description": "The status of ImagePullJob which has the failed nodes(status.Failed>0) .",
              "type": "array",
              "items": {
                "description": "FailedImageStatus the state of ImagePullJob which has the failed nodes(status.Failed>0)",
                "type": "object",
                "properties": {
                  "imagePullJob": {
                    "description": "The name of ImagePullJob which has the failed nodes(status.Failed>0)",
                    "type": "string"
                  },
                  "message": {
                    "description": "The text prompt for job running status.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the image",
                    "type": "string"
                  }
                }
              }
            },
            "startTime": {
              "description": "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "succeeded": {
              "description": "The number of image pull job which are finished and status.Succeeded==status.Desired.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJob",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.NodeImageList": {
      "description": "NodeImageList is a list of NodeImage",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of nodeimages. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.NodeImage"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "NodeImageList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.PersistentPodStateList": {
      "description": "PersistentPodStateList is a list of PersistentPodState",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of persistentpodstates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.PersistentPodState"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "PersistentPodStateList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.PodProbeMarker": {
      "description": "PodProbeMarker is the Schema for the PodProbeMarker API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "PodProbeMarkerSpec defines the desired state of PodProbeMarker",
          "type": "object",
          "required": [
            "probes",
            "selector"
          ],
          "properties": {
            "probes": {
              "description": "Custom container probe, current only support Exec(). Probe Result will record in Pod.Status.Conditions, and condition.type=probe.name. condition.status=True indicates probe success condition.status=False indicates probe fails",
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "containerName",
                  "name",
                  "probe"
                ],
                "properties": {
                  "containerName": {
                    "description": "container name",
                    "type": "string"
                  },
                  "markerPolicy": {
                    "description": "According to the execution result of ContainerProbe, perform specific actions, such as: patch Pod labels, annotations, ReadinessGate Condition It cannot be null at the same time as PodConditionType.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "state"
                      ],
                      "properties": {
                        "annotations": {
                          "description": "Patch annotations pod.annotations",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "labels": {
                          "description": "Patch Labels pod.labels",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "state": {
                          "description": "probe status, True or False For example: State=Succeeded, annotations[controller.kubernetes.io/pod-deletion-cost] = '10'. State=Failed, annotations[controller.kubernetes.io/pod-deletion-cost] = '-10'. In addition, if State=Failed is not defined, Exec execution fails, and the annotations[controller.kubernetes.io/pod-deletion-cost] will be Deleted",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "name": {
                    "description": "probe name, unique within the Pod(Even between different containers, they cannot be the same)",
                    "type": "string"
                  },
                  "podConditionType": {
                    "description": "If it is not empty, the Probe execution result will be recorded on the Pod condition. It cannot be null at the same time as MarkerPolicy. For example PodConditionType=game.kruise.io/healthy, pod.status.condition.type = game.kruise.io/healthy. When probe is Succeeded, pod.status.condition.status = True. Otherwise, when the probe fails to execute, pod.status.condition.status = False.",
                    "type": "string"
                  },
                  "probe": {
                    "description": "container probe spec",
                    "type": "object",
                    "properties": {
                      "exec": {
                        "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                        "type": "object",
                        "properties": {
                          "command": {
                            "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "failureThreshold": {
                        "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                        "type": "integer",
                        "format": "int32"
                      },
                      "httpGet": {
                        "description": "HTTPGet specifies the http request to perform.",
                        "type": "object",
                        "required": [
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                            "type": "string"
                          },
                          "httpHeaders": {
                            "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                            "type": "array",
                            "items": {
                              "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                              "type": "object",
                              "required": [
                                "name",
                                "value"
                              ],
                              "properties": {
                                "name": {
                                  "description": "The header field name",
                                  "type": "string"
                                },
                                "value": {
                                  "description": "The header field value",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "path": {
                            "description": "Path to access on the HTTP server.",
                            "type": "string"
                          },
                          "port": {
                            "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                            "x-kubernetes-int-or-string": true
                          },
                          "scheme": {
                            "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                            "type": "string"
                          }
                        }
                      },
                      "initialDelaySeconds": {
                        "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "integer",
                        "format": "int32"
                      },
                      "periodSeconds": {
                        "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                        "type": "integer",
                        "format": "int32"
                      },
                      "successThreshold": {
                        "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                        "type": "integer",
                        "format": "int32"
                      },
                      "tcpSocket": {
                        "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                        "type": "object",
                        "required": [
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "description": "Optional: Host name to connect to, defaults to the pod IP.",
                            "type": "string"
                          },
                          "port": {
                            "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      },
                      "terminationGracePeriodSeconds": {
                        "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "timeoutSeconds": {
                        "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "integer",
                        "format": "int32"
                      }
                    }
                  }
                }
              }
            },
            "selector": {
              "description": "Selector is a label query over pods that should exec custom probe It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "required": [
            "observedGeneration"
          ],
          "properties": {
            "matchedPods": {
              "description": "matched Pods",
              "type": "integer",
              "format": "int64"
            },
            "observedGeneration": {
              "description": "observedGeneration is the most recent generation observed for this PodProbeMarker. It corresponds to the PodProbeMarker's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarker",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.NodePodProbe": {
      "description": "NodePodProbe is the Schema for the NodePodProbe API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "NodePodProbeSpec defines the desired state of NodePodProbe",
          "type": "object",
          "properties": {
            "podProbes": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "namespace",
                  "uid"
                ],
                "properties": {
                  "name": {
                    "description": "pod name",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "pod namespace",
                    "type": "string"
                  },
                  "probes": {
                    "description": "Custom container probe, supports Exec, Tcp, and returns the result to Pod yaml",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "containerName",
                        "name",
                        "probe"
                      ],
                      "properties": {
                        "containerName": {
                          "description": "container name",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name is podProbeMarker.Name#probe.Name",
                          "type": "string"
                        },
                        "probe": {
                          "description": "container probe spec",
                          "type": "object",
                          "properties": {
                            "exec": {
                              "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                              "type": "object",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "failureThreshold": {
                              "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "httpGet": {
                              "description": "HTTPGet specifies the http request to perform.",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "type": "array",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "type": "object",
                                    "required": [
                                      "name",
                                      "value"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "The header field name",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                  "type": "string"
                                }
                              }
                            },
                            "initialDelaySeconds": {
                              "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                              "type": "integer",
                              "format": "int32"
                            },
                            "periodSeconds": {
                              "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "successThreshold": {
                              "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "tcpSocket": {
                              "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                }
                              }
                            },
                            "terminationGracePeriodSeconds": {
                              "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "timeoutSeconds": {
                              "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        }
                      }
                    }
                  },
                  "uid": {
                    "description": "pod uid",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "podProbeStatuses": {
              "description": "pod probe results",
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "namespace",
                  "uid"
                ],
                "properties": {
                  "name": {
                    "description": "pod name",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "pod namespace",
                    "type": "string"
                  },
                  "probeStates": {
                    "description": "pod probe result",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "name",
                        "state"
                      ],
                      "properties": {
                        "lastProbeTime": {
                          "description": "Last time we probed the condition.",
                          "type": "string",
                          "format": "date-time"
                        },
                        "lastTransitionTime": {
                          "description": "Last time the condition transitioned from one status to another.",
                          "type": "string",
                          "format": "date-time"
                        },
                        "message": {
                          "description": "If Status=True, Message records the return result of Probe. If Status=False, Message records Probe's error message",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name is podProbeMarker.Name#probe.Name",
                          "type": "string"
                        },
                        "state": {
                          "description": "container probe exec state, True or False",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "uid": {
                    "description": "pod uid",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "NodePodProbe",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.StatefulSetList": {
      "description": "StatefulSetList is a list of StatefulSet",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of statefulsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.StatefulSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "StatefulSetList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.CloneSet": {
      "description": "CloneSet is the Schema for the clonesets API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "CloneSetSpec defines the desired state of CloneSet",
          "type": "object",
          "required": [
            "selector",
            "template"
          ],
          "properties": {
            "lifecycle": {
              "description": "Lifecycle defines the lifecycle hooks for Pods pre-available(pre-normal), pre-delete, in-place update.",
              "type": "object",
              "properties": {
                "inPlaceUpdate": {
                  "description": "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preDelete": {
                  "description": "PreDelete is the hook before Pod to be deleted.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preNormal": {
                  "description": "PreNormal is the hook after Pod to be created and ready to be Normal.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "minReadySeconds": {
              "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
              "type": "integer",
              "format": "int32"
            },
            "replicas": {
              "description": "Replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template. If unspecified, defaults to 1.",
              "type": "integer",
              "format": "int32"
            },
            "revisionHistoryLimit": {
              "description": "RevisionHistoryLimit is the maximum number of revisions that will be maintained in the CloneSet's revision history. The revision history consists of all revisions not represented by a currently applied CloneSetSpec version. The default value is 10.",
              "type": "integer",
              "format": "int32"
            },
            "scaleStrategy": {
              "description": "ScaleStrategy indicates the ScaleStrategy that will be employed to create and delete Pods in the CloneSet.",
              "type": "object",
              "properties": {
                "disablePVCReuse": {
                  "description": "Indicate if cloneSet will reuse already existed pvc to rebuild a new pod",
                  "type": "boolean"
                },
                "maxUnavailable": {
                  "description": "The maximum number of pods that can be unavailable for scaled pods. This field can control the changes rate of replicas for CloneSet so as to minimize the impact for users' service. The scale will fail if the number of unavailable pods were greater than this MaxUnavailable at scaling up. MaxUnavailable works only when scaling up.",
                  "x-kubernetes-int-or-string": true
                },
                "podsToDelete": {
                  "description": "PodsToDelete is the names of Pod should be deleted. Note that this list will be truncated for non-existing pod names.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "selector": {
              "description": "Selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "template": {
              "description": "Template describes the pods that will be created.",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "updateStrategy": {
              "description": "UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.",
              "type": "object",
              "properties": {
                "inPlaceUpdateStrategy": {
                  "description": "InPlaceUpdateStrategy contains strategies for in-place update.",
                  "type": "object",
                  "properties": {
                    "gracePeriodSeconds": {
                      "description": "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "maxSurge": {
                  "description": "The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.",
                  "x-kubernetes-int-or-string": true
                },
                "maxUnavailable": {
                  "description": "The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.",
                  "x-kubernetes-int-or-string": true
                },
                "partition": {
                  "description": "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.",
                  "x-kubernetes-int-or-string": true
                },
                "paused": {
                  "description": "Paused indicates that the CloneSet is paused. Default value is false",
                  "type": "boolean"
                },
                "priorityStrategy": {
                  "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                  "type": "object",
                  "properties": {
                    "orderPriority": {
                      "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                      "type": "array",
                      "items": {
                        "description": "UpdatePriorityOrderTerm defines order priority.",
                        "type": "object",
                        "required": [
                          "orderedKey"
                        ],
                        "properties": {
                          "orderedKey": {
                            "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "weightPriority": {
                      "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                      "type": "array",
                      "items": {
                        "description": "UpdatePriorityWeightTerm defines weight priority.",
                        "type": "object",
                        "required": [
                          "matchSelector",
                          "weight"
                        ],
                        "properties": {
                          "matchSelector": {
                            "description": "MatchSelector is used to select by pod's labels.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "weight": {
                            "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      }
                    }
                  }
                },
                "scatterStrategy": {
                  "description": "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "key",
                      "value"
                    ],
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.",
                  "type": "string"
                }
              }
            },
            "volumeClaimTemplates": {
              "description": "VolumeClaimTemplates is a list of claims that pods are allowed to reference. Note that PVC will be deleted when its pod has been deleted.",
              "x-kubernetes-preserve-unknown-fields": true
            }
          }
        },
        "status": {
          "description": "CloneSetStatus defines the observed state of CloneSet",
          "type": "object",
          "required": [
            "availableReplicas",
            "readyReplicas",
            "replicas",
            "updatedAvailableReplicas",
            "updatedReadyReplicas",
            "updatedReplicas"
          ],
          "properties": {
            "availableReplicas": {
              "description": "AvailableReplicas is the number of Pods created by the CloneSet controller that have a Ready Condition for at least minReadySeconds.",
              "type": "integer",
              "format": "int32"
            },
            "collisionCount": {
              "description": "CollisionCount is the count of hash collisions for the CloneSet. The CloneSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "conditions": {
              "description": "Conditions represents the latest available observations of a CloneSet's current state.",
              "type": "array",
              "items": {
                "description": "CloneSetCondition describes the state of a CloneSet at a certain point.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of CloneSet condition.",
                    "type": "string"
                  }
                }
              }
            },
            "currentRevision": {
              "description": "currentRevision, if not empty, indicates the current revision version of the CloneSet.",
              "type": "string"
            },
            "expectedUpdatedReplicas": {
              "description": "ExpectedUpdatedReplicas is the number of Pods that should be updated by CloneSet controller. This field is calculated via Replicas - Partition.",
              "type": "integer",
              "format": "int32"
            },
            "labelSelector": {
              "description": "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the most recent generation observed for this CloneSet. It corresponds to the CloneSet's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "readyReplicas": {
              "description": "ReadyReplicas is the number of Pods created by the CloneSet controller that have a Ready Condition.",
              "type": "integer",
              "format": "int32"
            },
            "replicas": {
              "description": "Replicas is the number of Pods created by the CloneSet controller.",
              "type": "integer",
              "format": "int32"
            },
            "updateRevision": {
              "description": "UpdateRevision, if not empty, indicates the latest revision of the CloneSet.",
              "type": "string"
            },
            "updatedAvailableReplicas": {
              "description": "UpdatedAvailableReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision and have a Ready Condition for at least minReadySeconds.",
              "type": "integer",
              "format": "int32"
            },
            "updatedReadyReplicas": {
              "description": "UpdatedReadyReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision and have a Ready Condition.",
              "type": "integer",
              "format": "int32"
            },
            "updatedReplicas": {
              "description": "UpdatedReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "CloneSet",
          "version": "v1alpha1"
        }
      ]
    },
    "v1beta1.StatefulSet": {
      "description": "StatefulSet is the Schema for the statefulsets API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "StatefulSetSpec defines the desired state of StatefulSet",
          "type": "object",
          "required": [
            "selector",
            "template"
          ],
          "properties": {
            "lifecycle": {
              "description": "Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.",
              "type": "object",
              "properties": {
                "inPlaceUpdate": {
                  "description": "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preDelete": {
                  "description": "PreDelete is the hook before Pod to be deleted.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preNormal": {
                  "description": "PreNormal is the hook after Pod to be created and ready to be Normal.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "persistentVolumeClaimRetentionPolicy": {
              "description": "PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.",
              "type": "object",
              "properties": {
                "whenDeleted": {
                  "description": "WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.",
                  "type": "string"
                },
                "whenScaled": {
                  "description": "WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.",
                  "type": "string"
                }
              }
            },
            "podManagementPolicy": {
              "description": "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
              "type": "string"
            },
            "replicas": {
              "description": "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1. TODO: Consider a rename of this field.",
              "type": "integer",
              "format": "int32"
            },
            "reserveOrdinals": {
              "description": "reserveOrdinals controls the ordinal numbers that should be reserved, and the replicas will always be the expectation number of running Pods. For a sts with replicas=3 and its Pods in [0, 1, 2]: - If you want to migrate Pod-1 and reserve this ordinal, just set spec.reserveOrdinal to [1].   Then controller will delete Pod-1 and create Pod-3 (existing Pods will be [0, 2, 3]) - If you just want to delete Pod-1, you should set spec.reserveOrdinal to [1] and spec.replicas to 2.   Then controller will delete Pod-1 (existing Pods will be [0, 2])",
              "type": "array",
              "items": {
                "type": "integer"
              }
            },
            "revisionHistoryLimit": {
              "description": "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
              "type": "integer",
              "format": "int32"
            },
            "scaleStrategy": {
              "description": "scaleStrategy indicates the StatefulSetScaleStrategy that will be employed to scale Pods in the StatefulSet.",
              "type": "object",
              "properties": {
                "maxUnavailable": {
                  "description": "The maximum number of pods that can be unavailable during scaling. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. It can just be allowed to work with Parallel podManagementPolicy.",
                  "x-kubernetes-int-or-string": true
                }
              }
            },
            "selector": {
              "description": "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "serviceName": {
              "description": "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
              "type": "string"
            },
            "template": {
              "description": "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "updateStrategy": {
              "description": "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
              "type": "object",
              "properties": {
                "rollingUpdate": {
                  "description": "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
                  "type": "object",
                  "properties": {
                    "inPlaceUpdateStrategy": {
                      "description": "InPlaceUpdateStrategy contains strategies for in-place update.",
                      "type": "object",
                      "properties": {
                        "gracePeriodSeconds": {
                          "description": "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "maxUnavailable": {
                      "description": "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.",
                      "x-kubernetes-int-or-string": true
                    },
                    "minReadySeconds": {
                      "description": "MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "partition": {
                      "description": "Partition indicates the ordinal at which the StatefulSet should be partitioned by default. But if unorderedUpdate has been set:   - Partition indicates the number of pods with non-updated revisions when rolling update.   - It means controller will update $(replicas - partition) number of pod. Default value is 0.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "paused": {
                      "description": "Paused indicates that the StatefulSet is paused. Default value is false",
                      "type": "boolean"
                    },
                    "podUpdatePolicy": {
                      "description": "PodUpdatePolicy indicates how pods should be updated Default value is \"ReCreate\"",
                      "type": "string"
                    },
                    "unorderedUpdate": {
                      "description": "UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy",
                      "type": "object",
                      "properties": {
                        "priorityStrategy": {
                          "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                          "type": "object",
                          "properties": {
                            "orderPriority": {
                              "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                              "type": "array",
                              "items": {
                                "description": "UpdatePriorityOrderTerm defines order priority.",
                                "type": "object",
                                "required": [
                                  "orderedKey"
                                ],
                                "properties": {
                                  "orderedKey": {
                                    "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "weightPriority": {
                              "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                              "type": "array",
                              "items": {
                                "description": "UpdatePriorityWeightTerm defines weight priority.",
                                "type": "object",
                                "required": [
                                  "matchSelector",
                                  "weight"
                                ],
                                "properties": {
                                  "matchSelector": {
                                    "description": "MatchSelector is used to select by pod's labels.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
                  "type": "string"
                }
              }
            },
            "volumeClaimTemplates": {
              "description": "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name. TODO: Define the behavior if a claim already exists with the same name.",
              "x-kubernetes-preserve-unknown-fields": true
            }
          }
        },
        "status": {
          "description": "StatefulSetStatus defines the observed state of StatefulSet",
          "type": "object",
          "required": [
            "availableReplicas",
            "currentReplicas",
            "readyReplicas",
            "replicas",
            "updatedReplicas"
          ],
          "properties": {
            "availableReplicas": {
              "description": "AvailableReplicas is the number of Pods created by the StatefulSet controller that have been ready for minReadySeconds.",
              "type": "integer",
              "format": "int32"
            },
            "collisionCount": {
              "description": "collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "conditions": {
              "description": "Represents the latest available observations of a statefulset's current state.",
              "type": "array",
              "items": {
                "description": "StatefulSetCondition describes the state of a statefulset at a certain point.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of statefulset condition.",
                    "type": "string"
                  }
                }
              }
            },
            "currentReplicas": {
              "description": "currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.",
              "type": "integer",
              "format": "int32"
            },
            "currentRevision": {
              "description": "currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).",
              "type": "string"
            },
            "labelSelector": {
              "description": "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "readyReplicas": {
              "description": "readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.",
              "type": "integer",
              "format": "int32"
            },
            "replicas": {
              "description": "replicas is the number of Pods created by the StatefulSet controller.",
              "type": "integer",
              "format": "int32"
            },
            "updateRevision": {
              "description": "updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)",
              "type": "string"
            },
            "updatedAvailableReplicas": {
              "description": "updatedAvailableReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready condition for atleast minReadySeconds.",
              "type": "integer",
              "format": "int32"
            },
            "updatedReadyReplicas": {
              "description": "updatedReadyReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready Condition.",
              "type": "integer",
              "format": "int32"
            },
            "updatedReplicas": {
              "description": "updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1beta1"
        }
      ]
    },
    "v1alpha1.UnitedDeploymentList": {
      "description": "UnitedDeploymentList is a list of UnitedDeployment",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of uniteddeployments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.UnitedDeployment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "UnitedDeploymentList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.AdvancedCronJob": {
      "description": "AdvancedCronJob is the Schema for the advancedcronjobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "AdvancedCronJobSpec defines the desired state of AdvancedCronJob",
          "type": "object",
          "required": [
            "schedule",
            "template"
          ],
          "properties": {
            "concurrencyPolicy": {
              "description": "Specifies how to treat concurrent executions of a Job. Valid values are: - \"Allow\" (default): allows CronJobs to run concurrently; - \"Forbid\": forbids concurrent runs, skipping next run if previous run hasn't finished yet; - \"Replace\": cancels currently running job and replaces it with a new one",
              "type": "string",
              "enum": [
                "Allow",
                "Forbid",
                "Replace"
              ]
            },
            "failedJobsHistoryLimit": {
              "description": "The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.",
              "type": "integer",
              "format": "int32"
            },
            "paused": {
              "description": "Paused will pause the cron job.",
              "type": "boolean"
            },
            "schedule": {
              "description": "The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.",
              "type": "string",
              "minLength": 0
            },
            "startingDeadlineSeconds": {
              "description": "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
              "type": "integer",
              "format": "int64"
            },
            "successfulJobsHistoryLimit": {
              "description": "The number of successful finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.",
              "type": "integer",
              "format": "int32"
            },
            "template": {
              "description": "Specifies the job that will be created when executing a CronJob.",
              "type": "object",
              "properties": {
                "broadcastJobTemplate": {
                  "description": "Specifies the broadcastjob that will be created when executing a BroadcastCronJob.",
                  "type": "object",
                  "properties": {
                    "metadata": {
                      "description": "Standard object's metadata of the jobs created from this template.",
                      "type": "object"
                    },
                    "spec": {
                      "description": "Specification of the desired behavior of the broadcastjob.",
                      "type": "object",
                      "required": [
                        "template"
                      ],
                      "properties": {
                        "completionPolicy": {
                          "description": "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
                          "type": "object",
                          "properties": {
                            "activeDeadlineSeconds": {
                              "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "ttlSecondsAfterFinished": {
                              "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Only works for Always type",
                              "type": "integer",
                              "format": "int32"
                            },
                            "type": {
                              "description": "Type indicates the type of the CompletionPolicy. Default is Always.",
                              "type": "string"
                            }
                          }
                        },
                        "failurePolicy": {
                          "description": "FailurePolicy indicates the behavior of the job, when failed pod is found.",
                          "type": "object",
                          "properties": {
                            "restartLimit": {
                              "description": "RestartLimit specifies the number of retries before marking the pod failed.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "type": {
                              "description": "Type indicates the type of FailurePolicyType. Default is FailurePolicyTypeFailFast.",
                              "type": "string"
                            }
                          }
                        },
                        "parallelism": {
                          "description": "Parallelism specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when the work left to do is less than max parallelism. Not setting this value means no limit.",
                          "x-kubernetes-int-or-string": true
                        },
                        "paused": {
                          "description": "Paused will pause the job.",
                          "type": "boolean"
                        },
                        "template": {
                          "description": "Template describes the pod that will be created when executing a job.",
                          "x-kubernetes-preserve-unknown-fields": true
                        }
                      }
                    }
                  }
                },
                "jobTemplate": {
                  "description": "Specifies the job that will be created when executing a CronJob.",
                  "x-kubernetes-preserve-unknown-fields": true
                }
              }
            },
            "timeZone": {
              "description": "The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. If not specified, this will default to the time zone of the kruise-controller-manager process.",
              "type": "string"
            }
          }
        },
        "status": {
          "description": "AdvancedCronJobStatus defines the observed state of AdvancedCronJob",
          "type": "object",
          "properties": {
            "active": {
              "description": "A list of pointers to currently running jobs.",
              "type": "array",
              "items": {
                "description": "ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, \"must refer only to types A and B\" or \"UID not honored\" or \"name must be restricted\".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .",
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "description": "API version of the referent.",
                    "type": "string"
                  },
                  "fieldPath": {
                    "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                    "type": "string"
                  },
                  "kind": {
                    "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  },
                  "resourceVersion": {
                    "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                    "type": "string"
                  },
                  "uid": {
                    "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                    "type": "string"
                  }
                }
              }
            },
            "lastScheduleTime": {
              "description": "Information when was the last time the job was successfully scheduled.",
              "type": "string",
              "format": "date-time"
            },
            "type": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJob",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.AdvancedCronJobList": {
      "description": "AdvancedCronJobList is a list of AdvancedCronJob",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of advancedcronjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.AdvancedCronJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "AdvancedCronJobList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.DaemonSet": {
      "description": "DaemonSet is the Schema for the daemonsets API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "DaemonSetSpec defines the desired state of DaemonSet",
          "type": "object",
          "required": [
            "selector",
            "template"
          ],
          "properties": {
            "burstReplicas": {
              "description": "BurstReplicas is a rate limiter for booting pods on a lot of pods. The default value is 250",
              "x-kubernetes-int-or-string": true
            },
            "lifecycle": {
              "description": "Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update. Currently, we only support pre-delete hook for Advanced DaemonSet.",
              "type": "object",
              "properties": {
                "inPlaceUpdate": {
                  "description": "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preDelete": {
                  "description": "PreDelete is the hook before Pod to be deleted.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                },
                "preNormal": {
                  "description": "PreNormal is the hook after Pod to be created and ready to be Normal.",
                  "type": "object",
                  "properties": {
                    "finalizersHandler": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "labelsHandler": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "markPodNotReady": {
                      "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "minReadySeconds": {
              "description": "The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).",
              "type": "integer",
              "format": "int32"
            },
            "revisionHistoryLimit": {
              "description": "The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.",
              "type": "integer",
              "format": "int32"
            },
            "selector": {
              "description": "A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "template": {
              "description": "An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "updateStrategy": {
              "description": "An update strategy to replace existing DaemonSet pods with new pods.",
              "type": "object",
              "properties": {
                "rollingUpdate": {
                  "description": "Rolling update config params. Present only if type = \"RollingUpdate\".",
                  "type": "object",
                  "properties": {
                    "maxSurge": {
                      "description": "The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.",
                      "x-kubernetes-int-or-string": true
                    },
                    "maxUnavailable": {
                      "description": "The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.",
                      "x-kubernetes-int-or-string": true
                    },
                    "partition": {
                      "description": "The number of DaemonSet pods remained to be old version. Default value is 0. Maximum value is status.DesiredNumberScheduled, which means no pod will be updated.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "paused": {
                      "description": "Indicates that the daemon set is paused and will not be processed by the daemon set controller.",
                      "type": "boolean"
                    },
                    "rollingUpdateType": {
                      "description": "Type is to specify which kind of rollingUpdate.",
                      "type": "string"
                    },
                    "selector": {
                      "description": "A label query over nodes that are managed by the daemon set RollingUpdate. Must match in order to be controlled. It must match the node's labels.",
                      "type": "object",
                      "properties": {
                        "matchExpressions": {
                          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                          "type": "array",
                          "items": {
                            "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                            "type": "object",
                            "required": [
                              "key",
                              "operator"
                            ],
                            "properties": {
                              "key": {
                                "description": "key is the label key that the selector applies to.",
                                "type": "string"
                              },
                              "operator": {
                                "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                "type": "string"
                              },
                              "values": {
                                "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "matchLabels": {
                          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "DaemonSetStatus defines the observed state of DaemonSet",
          "type": "object",
          "required": [
            "currentNumberScheduled",
            "daemonSetHash",
            "desiredNumberScheduled",
            "numberMisscheduled",
            "numberReady",
            "updatedNumberScheduled"
          ],
          "properties": {
            "collisionCount": {
              "description": "Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "conditions": {
              "description": "Represents the latest available observations of a DaemonSet's current state.",
              "type": "array",
              "items": {
                "description": "DaemonSetCondition describes the state of a DaemonSet at a certain point.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of DaemonSet condition.",
                    "type": "string"
                  }
                }
              }
            },
            "currentNumberScheduled": {
              "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
              "type": "integer",
              "format": "int32"
            },
            "daemonSetHash": {
              "description": "DaemonSetHash is the controller-revision-hash, which represents the latest version of the DaemonSet.",
              "type": "string"
            },
            "desiredNumberScheduled": {
              "description": "The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
              "type": "integer",
              "format": "int32"
            },
            "numberAvailable": {
              "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)",
              "type": "integer",
              "format": "int32"
            },
            "numberMisscheduled": {
              "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
              "type": "integer",
              "format": "int32"
            },
            "numberReady": {
              "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.",
              "type": "integer",
              "format": "int32"
            },
            "numberUnavailable": {
              "description": "The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)",
              "type": "integer",
              "format": "int32"
            },
            "observedGeneration": {
              "description": "The most recent generation observed by the daemon set controller.",
              "type": "integer",
              "format": "int64"
            },
            "updatedNumberScheduled": {
              "description": "The total number of nodes that are running updated daemon pod",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "DaemonSet",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.CloneSetList": {
      "description": "CloneSetList is a list of CloneSet",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of clonesets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.CloneSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "CloneSetList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.ImageListPullJobList": {
      "description": "ImageListPullJobList is a list of ImageListPullJob",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of imagelistpulljobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.ImageListPullJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ImageListPullJobList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.EphemeralJobList": {
      "description": "EphemeralJobList is a list of EphemeralJob",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of ephemeraljobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.EphemeralJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "EphemeralJobList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.PersistentPodState": {
      "description": "PersistentPodState is the Schema for the PersistentPodState API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "PersistentPodStateSpec defines the desired state of PersistentPodState",
          "type": "object",
          "required": [
            "targetRef"
          ],
          "properties": {
            "persistentPodAnnotations": {
              "description": "Persist the annotations information of the pods that need to be saved",
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "key"
                ],
                "properties": {
                  "key": {
                    "type": "string"
                  }
                }
              }
            },
            "persistentPodStateRetentionPolicy": {
              "description": "PersistentPodStateRetentionPolicy describes the policy used for PodState. The default policy of 'WhenScaled' causes when scale down statefulSet, deleting it.",
              "type": "string"
            },
            "preferredPersistentTopology": {
              "description": "Pod rebuilt topology preferred for node labels, with xx weight for example  kubernetes.io/hostname, failure-domain.beta.kubernetes.io/zone",
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "preference",
                  "weight"
                ],
                "properties": {
                  "preference": {
                    "type": "object",
                    "required": [
                      "nodeTopologyKeys"
                    ],
                    "properties": {
                      "nodeTopologyKeys": {
                        "description": "A list of node selector requirements by node's labels.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "weight": {
                    "type": "integer",
                    "format": "int32"
                  }
                }
              }
            },
            "requiredPersistentTopology": {
              "description": "Pod rebuilt topology required for node labels for example kubernetes.io/hostname, failure-domain.beta.kubernetes.io/zone",
              "type": "object",
              "required": [
                "nodeTopologyKeys"
              ],
              "properties": {
                "nodeTopologyKeys": {
                  "description": "A list of node selector requirements by node's labels.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "targetRef": {
              "description": "TargetReference contains enough information to let you identify an workload for PersistentPodState Selector and TargetReference are mutually exclusive, TargetReference is priority to take effect current only support StatefulSet",
              "type": "object",
              "required": [
                "apiVersion",
                "kind",
                "name"
              ],
              "properties": {
                "apiVersion": {
                  "description": "API version of the referent.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the referent.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "required": [
            "observedGeneration"
          ],
          "properties": {
            "observedGeneration": {
              "description": "observedGeneration is the most recent generation observed for this PersistentPodState. It corresponds to the PersistentPodState's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "podStates": {
              "description": "When the pod is ready, record some status information of the pod, such as: labels, annotations, topologies, etc. map[string]PodState -> map[Pod.Name]PodState",
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "annotations": {
                    "description": "pod persistent annotations",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "nodeName": {
                    "description": "pod.spec.nodeName",
                    "type": "string"
                  },
                  "nodeTopologyLabels": {
                    "description": "node topology labels key=value for example kubernetes.io/hostname=node-1",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "PersistentPodState",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.ImagePullJobList": {
      "description": "ImagePullJobList is a list of ImagePullJob",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of imagepulljobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.ImagePullJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ImagePullJobList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.WorkloadSpread": {
      "description": "WorkloadSpread is the Schema for the WorkloadSpread API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "WorkloadSpreadSpec defines the desired state of WorkloadSpread.",
          "type": "object",
          "required": [
            "subsets",
            "targetRef"
          ],
          "properties": {
            "scheduleStrategy": {
              "description": "ScheduleStrategy indicates the strategy the WorkloadSpread used to preform the schedule between each of subsets.",
              "type": "object",
              "properties": {
                "adaptive": {
                  "description": "Adaptive is used to communicate parameters when Type is AdaptiveWorkloadSpreadScheduleStrategyType.",
                  "type": "object",
                  "properties": {
                    "disableSimulationSchedule": {
                      "description": "DisableSimulationSchedule indicates whether to disable the feature of simulation schedule. Default is false. Webhook can take a simple general predicates to check whether Pod can be scheduled into this subset, but it just considers the Node resource and cannot replace scheduler to do richer predicates practically.",
                      "type": "boolean"
                    },
                    "rescheduleCriticalSeconds": {
                      "description": "RescheduleCriticalSeconds indicates how long controller will reschedule a schedule failed Pod to the subset that has redundant capacity after the subset where the Pod lives. If a Pod was scheduled failed and still in a unschedulabe status over RescheduleCriticalSeconds duration, the controller will reschedule it to a suitable subset.",
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "type": {
                  "description": "Type indicates the type of the WorkloadSpreadScheduleStrategy. Default is Fixed",
                  "type": "string",
                  "enum": [
                    "Adaptive",
                    "Fixed",
                    ""
                  ]
                }
              }
            },
            "subsets": {
              "description": "Subsets describes the pods distribution details between each of subsets.",
              "type": "array",
              "items": {
                "description": "WorkloadSpreadSubset defines the details of a subset.",
                "type": "object",
                "required": [
                  "name"
                ],
                "properties": {
                  "maxReplicas": {
                    "description": "MaxReplicas indicates the desired max replicas of this subset.",
                    "x-kubernetes-int-or-string": true
                  },
                  "name": {
                    "description": "Name should be unique between all of the subsets under one WorkloadSpread.",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch indicates patching podTemplate to the Pod.",
                    "x-kubernetes-preserve-unknown-fields": true
                  },
                  "preferredNodeSelectorTerms": {
                    "description": "Indicates the node preferred selector to form the subset.",
                    "type": "array",
                    "items": {
                      "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                      "type": "object",
                      "required": [
                        "preference",
                        "weight"
                      ],
                      "properties": {
                        "preference": {
                          "description": "A node selector term, associated with the corresponding weight.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "A list of node selector requirements by node's labels.",
                              "type": "array",
                              "items": {
                                "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "The label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                    "type": "string"
                                  },
                                  "values": {
                                    "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchFields": {
                              "description": "A list of node selector requirements by node's fields.",
                              "type": "array",
                              "items": {
                                "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "The label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                    "type": "string"
                                  },
                                  "values": {
                                    "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "weight": {
                          "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    }
                  },
                  "requiredNodeSelectorTerm": {
                    "description": "Indicates the node required selector to form the subset.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "A list of node selector requirements by node's labels.",
                        "type": "array",
                        "items": {
                          "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "The label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                              "type": "string"
                            },
                            "values": {
                              "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "matchFields": {
                        "description": "A list of node selector requirements by node's fields.",
                        "type": "array",
                        "items": {
                          "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "The label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                              "type": "string"
                            },
                            "values": {
                              "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "tolerations": {
                    "description": "Indicates the tolerations the pods under this subset have.",
                    "type": "array",
                    "items": {
                      "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
                      "type": "object",
                      "properties": {
                        "effect": {
                          "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                          "type": "string"
                        },
                        "key": {
                          "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                          "type": "string"
                        },
                        "tolerationSeconds": {
                          "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "value": {
                          "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "targetRef": {
              "description": "TargetReference is the target workload that WorkloadSpread want to control.",
              "type": "object",
              "required": [
                "apiVersion",
                "kind",
                "name"
              ],
              "properties": {
                "apiVersion": {
                  "description": "API version of the referent.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the referent.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "WorkloadSpreadStatus defines the observed state of WorkloadSpread.",
          "type": "object",
          "properties": {
            "observedGeneration": {
              "description": "ObservedGeneration is the most recent generation observed for this WorkloadSpread. It corresponds to the WorkloadSpread's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "subsetStatuses": {
              "description": "Contains the status of each subset. Each element in this array represents one subset",
              "type": "array",
              "items": {
                "description": "WorkloadSpreadSubsetStatus defines the observed state of subset",
                "type": "object",
                "required": [
                  "missingReplicas",
                  "name",
                  "replicas"
                ],
                "properties": {
                  "conditions": {
                    "description": "Conditions is an array of current observed subset conditions.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "status",
                        "type"
                      ],
                      "properties": {
                        "lastTransitionTime": {
                          "description": "Last time the condition transitioned from one status to another.",
                          "type": "string",
                          "format": "date-time"
                        },
                        "message": {
                          "description": "A human readable message indicating details about the transition.",
                          "type": "string"
                        },
                        "reason": {
                          "description": "The reason for the condition's last transition.",
                          "type": "string"
                        },
                        "status": {
                          "description": "Status of the condition, one of True, False, Unknown.",
                          "type": "string"
                        },
                        "type": {
                          "description": "Type of in place set condition.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "creatingPods": {
                    "description": "CreatingPods contains information about pods whose creation was processed by the webhook handler but not yet been observed by the WorkloadSpread controller. A pod will be in this map from the time when the webhook handler processed the creation request to the time when the pod is seen by controller. The key in the map is the name of the pod and the value is the time when the webhook handler process the creation request. If the real creation didn't happen and a pod is still in this map, it will be removed from the list automatically by WorkloadSpread controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod creations.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "deletingPods": {
                    "description": "DeletingPods is similar with CreatingPods and it contains information about pod deletion.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "missingReplicas": {
                    "description": "MissingReplicas is the number of active replicas belong to this subset not be found. MissingReplicas > 0 indicates the subset is still missing MissingReplicas pods to create MissingReplicas = 0 indicates the subset already has enough pods, there is no need to create MissingReplicas = -1 indicates the subset's MaxReplicas not set, then there is no limit for pods number",
                    "type": "integer",
                    "format": "int32"
                  },
                  "name": {
                    "description": "Name should be unique between all of the subsets under one WorkloadSpread.",
                    "type": "string"
                  },
                  "replicas": {
                    "description": "Replicas is the most recently observed number of active replicas for subset.",
                    "type": "integer",
                    "format": "int32"
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "WorkloadSpread",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.DaemonSetList": {
      "description": "DaemonSetList is a list of DaemonSet",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of daemonsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.DaemonSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "DaemonSetList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.StatefulSet": {
      "description": "StatefulSet is the Schema for the statefulsets API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "StatefulSetSpec defines the desired state of StatefulSet",
          "type": "object",
          "required": [
            "selector",
            "template"
          ],
          "properties": {
            "podManagementPolicy": {
              "description": "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
              "type": "string"
            },
            "replicas": {
              "description": "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1. TODO: Consider a rename of this field.",
              "type": "integer",
              "format": "int32"
            },
            "revisionHistoryLimit": {
              "description": "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
              "type": "integer",
              "format": "int32"
            },
            "selector": {
              "description": "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "serviceName": {
              "description": "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
              "type": "string"
            },
            "template": {
              "description": "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "updateStrategy": {
              "description": "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
              "type": "object",
              "properties": {
                "rollingUpdate": {
                  "description": "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
                  "type": "object",
                  "properties": {
                    "inPlaceUpdateStrategy": {
                      "description": "InPlaceUpdateStrategy contains strategies for in-place update.",
                      "type": "object",
                      "properties": {
                        "gracePeriodSeconds": {
                          "description": "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "maxUnavailable": {
                      "description": "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.",
                      "x-kubernetes-int-or-string": true
                    },
                    "minReadySeconds": {
                      "description": "MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "partition": {
                      "description": "Partition indicates the ordinal at which the StatefulSet should be partitioned by default. But if unorderedUpdate has been set:   - Partition indicates the number of pods with non-updated revisions when rolling update.   - It means controller will update $(replicas - partition) number of pod. Default value is 0.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "paused": {
                      "description": "Paused indicates that the StatefulSet is paused. Default value is false",
                      "type": "boolean"
                    },
                    "podUpdatePolicy": {
                      "description": "PodUpdatePolicy indicates how pods should be updated Default value is \"ReCreate\"",
                      "type": "string"
                    },
                    "unorderedUpdate": {
                      "description": "UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy",
                      "type": "object",
                      "properties": {
                        "priorityStrategy": {
                          "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                          "type": "object",
                          "properties": {
                            "orderPriority": {
                              "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                              "type": "array",
                              "items": {
                                "description": "UpdatePriorityOrderTerm defines order priority.",
                                "type": "object",
                                "required": [
                                  "orderedKey"
                                ],
                                "properties": {
                                  "orderedKey": {
                                    "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "weightPriority": {
                              "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                              "type": "array",
                              "items": {
                                "description": "UpdatePriorityWeightTerm defines weight priority.",
                                "type": "object",
                                "required": [
                                  "matchSelector",
                                  "weight"
                                ],
                                "properties": {
                                  "matchSelector": {
                                    "description": "MatchSelector is used to select by pod's labels.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
                  "type": "string"
                }
              }
            },
            "volumeClaimTemplates": {
              "description": "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name. TODO: Define the behavior if a claim already exists with the same name.",
              "x-kubernetes-preserve-unknown-fields": true
            }
          }
        },
        "status": {
          "description": "StatefulSetStatus defines the observed state of StatefulSet",
          "type": "object",
          "required": [
            "availableReplicas",
            "currentReplicas",
            "readyReplicas",
            "replicas",
            "updatedReplicas"
          ],
          "properties": {
            "availableReplicas": {
              "description": "AvailableReplicas is the number of Pods created by the StatefulSet controller that have been ready for minReadySeconds.",
              "type": "integer",
              "format": "int32"
            },
            "collisionCount": {
              "description": "collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "conditions": {
              "description": "Represents the latest available observations of a statefulset's current state.",
              "type": "array",
              "items": {
                "description": "StatefulSetCondition describes the state of a statefulset at a certain point.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of statefulset condition.",
                    "type": "string"
                  }
                }
              }
            },
            "currentReplicas": {
              "description": "currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.",
              "type": "integer",
              "format": "int32"
            },
            "currentRevision": {
              "description": "currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).",
              "type": "string"
            },
            "labelSelector": {
              "description": "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "readyReplicas": {
              "description": "readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.",
              "type": "integer",
              "format": "int32"
            },
            "replicas": {
              "description": "replicas is the number of Pods created by the StatefulSet controller.",
              "type": "integer",
              "format": "int32"
            },
            "updateRevision": {
              "description": "updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)",
              "type": "string"
            },
            "updatedReplicas": {
              "description": "updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "StatefulSet",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.ContainerRecreateRequestList": {
      "description": "ContainerRecreateRequestList is a list of ContainerRecreateRequest",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of containerrecreaterequests. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.ContainerRecreateRequest"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequestList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.ResourceDistribution": {
      "description": "ResourceDistribution is the Schema for the resourcedistributions API.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "ResourceDistributionSpec defines the desired state of ResourceDistribution.",
          "type": "object",
          "required": [
            "resource",
            "targets"
          ],
          "properties": {
            "resource": {
              "description": "Resource must be the complete yaml that users want to distribute.",
              "x-kubernetes-embedded-resource": true,
              "x-kubernetes-preserve-unknown-fields": true
            },
            "targets": {
              "description": "Targets defines the namespaces that users want to distribute to.",
              "type": "object",
              "properties": {
                "allNamespaces": {
                  "description": "If AllNamespaces is true, Resource will be distributed to the all namespaces (except some forbidden namespaces, such as \"kube-system\" and \"kube-public\").",
                  "type": "boolean"
                },
                "excludedNamespaces": {
                  "description": "If ExcludedNamespaces is not empty, Resource will never be distributed to the listed namespaces. ExcludedNamespaces has the highest priority.",
                  "type": "object",
                  "properties": {
                    "list": {
                      "type": "array",
                      "items": {
                        "description": "ResourceDistributionNamespace contains a namespace name",
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "Namespace name",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "includedNamespaces": {
                  "description": "If IncludedNamespaces is not empty, Resource will be distributed to the listed namespaces.",
                  "type": "object",
                  "properties": {
                    "list": {
                      "type": "array",
                      "items": {
                        "description": "ResourceDistributionNamespace contains a namespace name",
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "Namespace name",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "namespaceLabelSelector": {
                  "description": "If NamespaceLabelSelector is not empty, Resource will be distributed to the matched namespaces.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string"
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "description": "ResourceDistributionStatus defines the observed state of ResourceDistribution. ResourceDistributionStatus is recorded by kruise, users' modification is invalid and meaningless.",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions describe the condition when Resource creating, updating and deleting.",
              "type": "array",
              "items": {
                "description": "ResourceDistributionCondition allows a row to be marked with additional information.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "failedNamespace": {
                    "description": "FailedNamespaces describe all failed namespaces when Status is False",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "lastTransitionTime": {
                    "description": "LastTransitionTime is the last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "reason": {
                    "description": "Reason describe human readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of ResourceDistributionCondition.",
                    "type": "string"
                  }
                }
              }
            },
            "desired": {
              "description": "Desired represents the number of total target namespaces.",
              "type": "integer",
              "format": "int32"
            },
            "failed": {
              "description": "Failed represents the number of failed distributions.",
              "type": "integer",
              "format": "int32"
            },
            "observedGeneration": {
              "description": "ObservedGeneration represents the .metadata.generation that the condition was set based upon.",
              "type": "integer",
              "format": "int64"
            },
            "succeeded": {
              "description": "Succeeded represents the number of successful distributions.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ResourceDistribution",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.PodProbeMarkerList": {
      "description": "PodProbeMarkerList is a list of PodProbeMarker",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of podprobemarkers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.PodProbeMarker"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "PodProbeMarkerList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.BroadcastJobList": {
      "description": "BroadcastJobList is a list of BroadcastJob",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of broadcastjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.BroadcastJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "BroadcastJobList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.BroadcastJob": {
      "description": "BroadcastJob is the Schema for the broadcastjobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "BroadcastJobSpec defines the desired state of BroadcastJob",
          "type": "object",
          "required": [
            "template"
          ],
          "properties": {
            "completionPolicy": {
              "description": "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
              "type": "object",
              "properties": {
                "activeDeadlineSeconds": {
                  "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
                  "type": "integer",
                  "format": "int64"
                },
                "ttlSecondsAfterFinished": {
                  "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Only works for Always type",
                  "type": "integer",
                  "format": "int32"
                },
                "type": {
                  "description": "Type indicates the type of the CompletionPolicy. Default is Always.",
                  "type": "string"
                }
              }
            },
            "failurePolicy": {
              "description": "FailurePolicy indicates the behavior of the job, when failed pod is found.",
              "type": "object",
              "properties": {
                "restartLimit": {
                  "description": "RestartLimit specifies the number of retries before marking the pod failed.",
                  "type": "integer",
                  "format": "int32"
                },
                "type": {
                  "description": "Type indicates the type of FailurePolicyType. Default is FailurePolicyTypeFailFast.",
                  "type": "string"
                }
              }
            },
            "parallelism": {
              "description": "Parallelism specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when the work left to do is less than max parallelism. Not setting this value means no limit.",
              "x-kubernetes-int-or-string": true
            },
            "paused": {
              "description": "Paused will pause the job.",
              "type": "boolean"
            },
            "template": {
              "description": "Template describes the pod that will be created when executing a job.",
              "x-kubernetes-preserve-unknown-fields": true
            }
          }
        },
        "status": {
          "description": "BroadcastJobStatus defines the observed state of BroadcastJob",
          "type": "object",
          "properties": {
            "active": {
              "description": "The number of actively running pods.",
              "type": "integer",
              "format": "int32"
            },
            "completionTime": {
              "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "conditions": {
              "description": "The latest available observations of an object's current state.",
              "type": "array",
              "items": {
                "description": "JobCondition describes current state of a job.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastProbeTime": {
                    "description": "Last time the condition was checked.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "lastTransitionTime": {
                    "description": "Last time the condition transit from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "Human readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "(brief) reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of job condition, Complete or Failed.",
                    "type": "string"
                  }
                }
              }
            },
            "desired": {
              "description": "The desired number of pods, this is typically equal to the number of nodes satisfied to run pods.",
              "type": "integer",
              "format": "int32"
            },
            "failed": {
              "description": "The number of pods which reached phase Failed.",
              "type": "integer",
              "format": "int32"
            },
            "phase": {
              "description": "The phase of the job.",
              "type": "string"
            },
            "startTime": {
              "description": "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "succeeded": {
              "description": "The number of pods which reached phase Succeeded.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "BroadcastJob",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.UnitedDeployment": {
      "description": "UnitedDeployment is the Schema for the uniteddeployments API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "UnitedDeploymentSpec defines the desired state of UnitedDeployment.",
          "type": "object",
          "required": [
            "selector"
          ],
          "properties": {
            "replicas": {
              "description": "Replicas is the total desired replicas of all the subsets. If unspecified, defaults to 1.",
              "type": "integer",
              "format": "int32"
            },
            "revisionHistoryLimit": {
              "description": "Indicates the number of histories to be conserved. If unspecified, defaults to 10.",
              "type": "integer",
              "format": "int32"
            },
            "selector": {
              "description": "Selector is a label query over pods that should match the replica count. It must match the pod template's labels.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "template": {
              "description": "Template describes the subset that will be created.",
              "type": "object",
              "properties": {
                "advancedStatefulSetTemplate": {
                  "description": "AdvancedStatefulSet template",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "metadata": {
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "spec": {
                      "description": "StatefulSetSpec defines the desired state of StatefulSet",
                      "type": "object",
                      "required": [
                        "selector",
                        "template"
                      ],
                      "properties": {
                        "lifecycle": {
                          "description": "Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.",
                          "type": "object",
                          "properties": {
                            "inPlaceUpdate": {
                              "description": "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            },
                            "preDelete": {
                              "description": "PreDelete is the hook before Pod to be deleted.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            },
                            "preNormal": {
                              "description": "PreNormal is the hook after Pod to be created and ready to be Normal.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            }
                          }
                        },
                        "persistentVolumeClaimRetentionPolicy": {
                          "description": "PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.",
                          "type": "object",
                          "properties": {
                            "whenDeleted": {
                              "description": "WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.",
                              "type": "string"
                            },
                            "whenScaled": {
                              "description": "WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.",
                              "type": "string"
                            }
                          }
                        },
                        "podManagementPolicy": {
                          "description": "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
                          "type": "string"
                        },
                        "replicas": {
                          "description": "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1. TODO: Consider a rename of this field.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "reserveOrdinals": {
                          "description": "reserveOrdinals controls the ordinal numbers that should be reserved, and the replicas will always be the expectation number of running Pods. For a sts with replicas=3 and its Pods in [0, 1, 2]: - If you want to migrate Pod-1 and reserve this ordinal, just set spec.reserveOrdinal to [1].   Then controller will delete Pod-1 and create Pod-3 (existing Pods will be [0, 2, 3]) - If you just want to delete Pod-1, you should set spec.reserveOrdinal to [1] and spec.replicas to 2.   Then controller will delete Pod-1 (existing Pods will be [0, 2])",
                          "type": "array",
                          "items": {
                            "type": "integer"
                          }
                        },
                        "revisionHistoryLimit": {
                          "description": "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "scaleStrategy": {
                          "description": "scaleStrategy indicates the StatefulSetScaleStrategy that will be employed to scale Pods in the StatefulSet.",
                          "type": "object",
                          "properties": {
                            "maxUnavailable": {
                              "description": "The maximum number of pods that can be unavailable during scaling. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. It can just be allowed to work with Parallel podManagementPolicy.",
                              "x-kubernetes-int-or-string": true
                            }
                          }
                        },
                        "selector": {
                          "description": "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string"
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "serviceName": {
                          "description": "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
                          "type": "string"
                        },
                        "template": {
                          "description": "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
                          "x-kubernetes-preserve-unknown-fields": true
                        },
                        "updateStrategy": {
                          "description": "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
                          "type": "object",
                          "properties": {
                            "rollingUpdate": {
                              "description": "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
                              "type": "object",
                              "properties": {
                                "inPlaceUpdateStrategy": {
                                  "description": "InPlaceUpdateStrategy contains strategies for in-place update.",
                                  "type": "object",
                                  "properties": {
                                    "gracePeriodSeconds": {
                                      "description": "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
                                      "type": "integer",
                                      "format": "int32"
                                    }
                                  }
                                },
                                "maxUnavailable": {
                                  "description": "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.",
                                  "x-kubernetes-int-or-string": true
                                },
                                "minReadySeconds": {
                                  "description": "MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "partition": {
                                  "description": "Partition indicates the ordinal at which the StatefulSet should be partitioned by default. But if unorderedUpdate has been set:   - Partition indicates the number of pods with non-updated revisions when rolling update.   - It means controller will update $(replicas - partition) number of pod. Default value is 0.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "paused": {
                                  "description": "Paused indicates that the StatefulSet is paused. Default value is false",
                                  "type": "boolean"
                                },
                                "podUpdatePolicy": {
                                  "description": "PodUpdatePolicy indicates how pods should be updated Default value is \"ReCreate\"",
                                  "type": "string"
                                },
                                "unorderedUpdate": {
                                  "description": "UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy",
                                  "type": "object",
                                  "properties": {
                                    "priorityStrategy": {
                                      "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                                      "type": "object",
                                      "properties": {
                                        "orderPriority": {
                                          "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                                          "type": "array",
                                          "items": {
                                            "description": "UpdatePriorityOrderTerm defines order priority.",
                                            "type": "object",
                                            "required": [
                                              "orderedKey"
                                            ],
                                            "properties": {
                                              "orderedKey": {
                                                "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "weightPriority": {
                                          "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                                          "type": "array",
                                          "items": {
                                            "description": "UpdatePriorityWeightTerm defines weight priority.",
                                            "type": "object",
                                            "required": [
                                              "matchSelector",
                                              "weight"
                                            ],
                                            "properties": {
                                              "matchSelector": {
                                                "description": "MatchSelector is used to select by pod's labels.",
                                                "type": "object",
                                                "properties": {
                                                  "matchExpressions": {
                                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                                    "type": "array",
                                                    "items": {
                                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                      "type": "object",
                                                      "required": [
                                                        "key",
                                                        "operator"
                                                      ],
                                                      "properties": {
                                                        "key": {
                                                          "description": "key is the label key that the selector applies to.",
                                                          "type": "string"
                                                        },
                                                        "operator": {
                                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                          "type": "string"
                                                        },
                                                        "values": {
                                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                          "type": "array",
                                                          "items": {
                                                            "type": "string"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "matchLabels": {
                                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                                    "type": "object",
                                                    "additionalProperties": {
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              },
                                              "weight": {
                                                "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                                                "type": "integer",
                                                "format": "int32"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "type": {
                              "description": "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
                              "type": "string"
                            }
                          }
                        },
                        "volumeClaimTemplates": {
                          "description": "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name. TODO: Define the behavior if a claim already exists with the same name.",
                          "x-kubernetes-preserve-unknown-fields": true
                        }
                      }
                    }
                  }
                },
                "cloneSetTemplate": {
                  "description": "CloneSet template",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "metadata": {
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "spec": {
                      "description": "CloneSetSpec defines the desired state of CloneSet",
                      "type": "object",
                      "required": [
                        "selector",
                        "template"
                      ],
                      "properties": {
                        "lifecycle": {
                          "description": "Lifecycle defines the lifecycle hooks for Pods pre-available(pre-normal), pre-delete, in-place update.",
                          "type": "object",
                          "properties": {
                            "inPlaceUpdate": {
                              "description": "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            },
                            "preDelete": {
                              "description": "PreDelete is the hook before Pod to be deleted.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            },
                            "preNormal": {
                              "description": "PreNormal is the hook after Pod to be created and ready to be Normal.",
                              "type": "object",
                              "properties": {
                                "finalizersHandler": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "labelsHandler": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "markPodNotReady": {
                                  "description": "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
                                  "type": "boolean"
                                }
                              }
                            }
                          }
                        },
                        "minReadySeconds": {
                          "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
                          "type": "integer",
                          "format": "int32"
                        },
                        "replicas": {
                          "description": "Replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template. If unspecified, defaults to 1.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "revisionHistoryLimit": {
                          "description": "RevisionHistoryLimit is the maximum number of revisions that will be maintained in the CloneSet's revision history. The revision history consists of all revisions not represented by a currently applied CloneSetSpec version. The default value is 10.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "scaleStrategy": {
                          "description": "ScaleStrategy indicates the ScaleStrategy that will be employed to create and delete Pods in the CloneSet.",
                          "type": "object",
                          "properties": {
                            "disablePVCReuse": {
                              "description": "Indicate if cloneSet will reuse already existed pvc to rebuild a new pod",
                              "type": "boolean"
                            },
                            "maxUnavailable": {
                              "description": "The maximum number of pods that can be unavailable for scaled pods. This field can control the changes rate of replicas for CloneSet so as to minimize the impact for users' service. The scale will fail if the number of unavailable pods were greater than this MaxUnavailable at scaling up. MaxUnavailable works only when scaling up.",
                              "x-kubernetes-int-or-string": true
                            },
                            "podsToDelete": {
                              "description": "PodsToDelete is the names of Pod should be deleted. Note that this list will be truncated for non-existing pod names.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "selector": {
                          "description": "Selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string"
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "template": {
                          "description": "Template describes the pods that will be created.",
                          "x-kubernetes-preserve-unknown-fields": true
                        },
                        "updateStrategy": {
                          "description": "UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.",
                          "type": "object",
                          "properties": {
                            "inPlaceUpdateStrategy": {
                              "description": "InPlaceUpdateStrategy contains strategies for in-place update.",
                              "type": "object",
                              "properties": {
                                "gracePeriodSeconds": {
                                  "description": "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
                                  "type": "integer",
                                  "format": "int32"
                                }
                              }
                            },
                            "maxSurge": {
                              "description": "The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.",
                              "x-kubernetes-int-or-string": true
                            },
                            "maxUnavailable": {
                              "description": "The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.",
                              "x-kubernetes-int-or-string": true
                            },
                            "partition": {
                              "description": "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.",
                              "x-kubernetes-int-or-string": true
                            },
                            "paused": {
                              "description": "Paused indicates that the CloneSet is paused. Default value is false",
                              "type": "boolean"
                            },
                            "priorityStrategy": {
                              "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                              "type": "object",
                              "properties": {
                                "orderPriority": {
                                  "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                                  "type": "array",
                                  "items": {
                                    "description": "UpdatePriorityOrderTerm defines order priority.",
                                    "type": "object",
                                    "required": [
                                      "orderedKey"
                                    ],
                                    "properties": {
                                      "orderedKey": {
                                        "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "weightPriority": {
                                  "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                                  "type": "array",
                                  "items": {
                                    "description": "UpdatePriorityWeightTerm defines weight priority.",
                                    "type": "object",
                                    "required": [
                                      "matchSelector",
                                      "weight"
                                    ],
                                    "properties": {
                                      "matchSelector": {
                                        "description": "MatchSelector is used to select by pod's labels.",
                                        "type": "object",
                                        "properties": {
                                          "matchExpressions": {
                                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                            "type": "array",
                                            "items": {
                                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                              "type": "object",
                                              "required": [
                                                "key",
                                                "operator"
                                              ],
                                              "properties": {
                                                "key": {
                                                  "description": "key is the label key that the selector applies to.",
                                                  "type": "string"
                                                },
                                                "operator": {
                                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                  "type": "string"
                                                },
                                                "values": {
                                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "matchLabels": {
                                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "weight": {
                                        "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                                        "type": "integer",
                                        "format": "int32"
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "scatterStrategy": {
                              "description": "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": [
                                  "key",
                                  "value"
                                ],
                                "properties": {
                                  "key": {
                                    "type": "string"
                                  },
                                  "value": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "type": {
                              "description": "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.",
                              "type": "string"
                            }
                          }
                        },
                        "volumeClaimTemplates": {
                          "description": "VolumeClaimTemplates is a list of claims that pods are allowed to reference. Note that PVC will be deleted when its pod has been deleted.",
                          "x-kubernetes-preserve-unknown-fields": true
                        }
                      }
                    }
                  }
                },
                "deploymentTemplate": {
                  "description": "Deployment template",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "metadata": {
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "spec": {
                      "x-kubernetes-preserve-unknown-fields": true
                    }
                  }
                },
                "statefulSetTemplate": {
                  "description": "StatefulSet template",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "metadata": {
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "spec": {
                      "x-kubernetes-preserve-unknown-fields": true
                    }
                  }
                }
              }
            },
            "topology": {
              "description": "Topology describes the pods distribution detail between each of subsets.",
              "type": "object",
              "properties": {
                "subsets": {
                  "description": "Contains the details of each subset. Each element in this array represents one subset which will be provisioned and managed by UnitedDeployment.",
                  "type": "array",
                  "items": {
                    "description": "Subset defines the detail of a subset.",
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "description": "Indicates subset name as a DNS_LABEL, which will be used to generate subset workload name prefix in the format '<deployment-name>-<subset-name>-'. Name should be unique between all of the subsets under one UnitedDeployment.",
                        "type": "string"
                      },
                      "nodeSelectorTerm": {
                        "description": "Indicates the node selector to form the subset. Depending on the node selector, pods provisioned could be distributed across multiple groups of nodes. A subset's nodeSelectorTerm is not allowed to be updated.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "A list of node selector requirements by node's labels.",
                            "type": "array",
                            "items": {
                              "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "The label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchFields": {
                            "description": "A list of node selector requirements by node's fields.",
                            "type": "array",
                            "items": {
                              "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "The label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "patch": {
                        "description": "Patch indicates patching to the templateSpec. Patch takes precedence over other fields If the Patch also modifies the Replicas, NodeSelectorTerm or Tolerations, use value in the Patch",
                        "x-kubernetes-preserve-unknown-fields": true
                      },
                      "replicas": {
                        "description": "Indicates the number of the pod to be created under this subset. Replicas could also be percentage like '10%', which means 10% of UnitedDeployment replicas of pods will be distributed under this subset. If nil, the number of replicas in this subset is determined by controller. Controller will try to keep all the subsets with nil replicas have average pods.",
                        "x-kubernetes-int-or-string": true
                      },
                      "tolerations": {
                        "description": "Indicates the tolerations the pods under this subset have. A subset's tolerations is not allowed to be updated.",
                        "type": "array",
                        "items": {
                          "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
                          "type": "object",
                          "properties": {
                            "effect": {
                              "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                              "type": "string"
                            },
                            "key": {
                              "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                              "type": "string"
                            },
                            "tolerationSeconds": {
                              "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "value": {
                              "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "updateStrategy": {
              "description": "UpdateStrategy indicates the strategy the UnitedDeployment use to preform the update, when template is changed.",
              "type": "object",
              "properties": {
                "manualUpdate": {
                  "description": "Includes all of the parameters a Manual update strategy needs.",
                  "type": "object",
                  "properties": {
                    "partitions": {
                      "description": "Indicates number of subset partition.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "integer",
                        "format": "int32"
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type of UnitedDeployment update strategy. Default is Manual.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "UnitedDeploymentStatus defines the observed state of UnitedDeployment.",
          "type": "object",
          "required": [
            "currentRevision",
            "replicas",
            "updatedReplicas"
          ],
          "properties": {
            "collisionCount": {
              "description": "Count of hash collisions for the UnitedDeployment. The UnitedDeployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "conditions": {
              "description": "Represents the latest available observations of a UnitedDeployment's current state.",
              "type": "array",
              "items": {
                "description": "UnitedDeploymentCondition describes current state of a UnitedDeployment.",
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of in place set condition.",
                    "type": "string"
                  }
                }
              }
            },
            "currentRevision": {
              "description": "CurrentRevision, if not empty, indicates the current version of the UnitedDeployment.",
              "type": "string"
            },
            "labelSelector": {
              "description": "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the most recent generation observed for this UnitedDeployment. It corresponds to the UnitedDeployment's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "readyReplicas": {
              "description": "The number of ready replicas.",
              "type": "integer",
              "format": "int32"
            },
            "replicas": {
              "description": "Replicas is the most recently observed number of replicas.",
              "type": "integer",
              "format": "int32"
            },
            "subsetReplicas": {
              "description": "Records the topology detail information of the replicas of each subset.",
              "type": "object",
              "additionalProperties": {
                "type": "integer",
                "format": "int32"
              }
            },
            "updateStatus": {
              "description": "Records the information of update progress.",
              "type": "object",
              "properties": {
                "currentPartitions": {
                  "description": "Records the current partition.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "integer",
                    "format": "int32"
                  }
                },
                "updatedRevision": {
                  "description": "Records the latest revision.",
                  "type": "string"
                }
              }
            },
            "updatedReadyReplicas": {
              "description": "The number of ready current revision replicas for this UnitedDeployment.",
              "type": "integer",
              "format": "int32"
            },
            "updatedReplicas": {
              "description": "The number of pods in current version.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "UnitedDeployment",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.SidecarSet": {
      "description": "SidecarSet is the Schema for the sidecarsets API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "SidecarSetSpec defines the desired state of SidecarSet",
          "type": "object",
          "properties": {
            "containers": {
              "description": "Containers is the list of sidecar containers to be injected into the selected pod",
              "type": "array",
              "items": {
                "description": "SidecarContainer defines the container of Sidecar",
                "x-kubernetes-preserve-unknown-fields": true
              }
            },
            "imagePullSecrets": {
              "description": "List of the names of secrets required by pulling sidecar container images",
              "type": "array",
              "items": {
                "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
                "type": "object",
                "properties": {
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                    "type": "string"
                  }
                }
              }
            },
            "initContainers": {
              "description": "InitContainers is the list of init containers to be injected into the selected pod We will inject those containers by their name in ascending order We only inject init containers when a new pod is created, it does not apply to any existing pod",
              "type": "array",
              "items": {
                "description": "SidecarContainer defines the container of Sidecar",
                "x-kubernetes-preserve-unknown-fields": true
              }
            },
            "injectionStrategy": {
              "description": "InjectionStrategy describe the strategy when sidecarset is injected into pods",
              "type": "object",
              "properties": {
                "paused": {
                  "description": "Paused indicates that SidecarSet will suspend injection into Pods If Paused is true, the sidecarSet will not be injected to newly created Pods, but the injected sidecar container remains updating and running. default is false",
                  "type": "boolean"
                },
                "revision": {
                  "description": "Revision can help users rolling update SidecarSet safely. If users set this filed, SidecarSet will try to inject specific revision according to different policies.",
                  "type": "object",
                  "properties": {
                    "customVersion": {
                      "description": "CustomVersion corresponds to label 'apps.kruise.io/sidecarset-custom-version' of (History) SidecarSet. SidecarSet will select the specific ControllerRevision via this CustomVersion, and then restore the history SidecarSet to inject specific version of the sidecar to pods.",
                      "type": "string"
                    },
                    "policy": {
                      "description": "Policy describes the behavior of revision injection. Defaults to Always.",
                      "type": "string"
                    },
                    "revisionName": {
                      "description": "RevisionName corresponds to a specific ControllerRevision name of SidecarSet that you want to inject to Pods.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "namespace": {
              "description": "Namespace sidecarSet will only match the pods in the namespace otherwise, match pods in all namespaces(in cluster)",
              "type": "string"
            },
            "namespaceSelector": {
              "description": "NamespaceSelector select which namespaces to inject sidecar containers. Default to the empty LabelSelector, which matches everything.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "patchPodMetadata": {
              "description": "SidecarSet support to inject & in-place update metadata in pod.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "annotations": {
                    "description": "annotations",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "patchPolicy": {
                    "description": "labels map[string]string `json:\"labels,omitempty\"` patch pod metadata policy, Default is \"Retain\"",
                    "type": "string"
                  }
                }
              }
            },
            "revisionHistoryLimit": {
              "description": "RevisionHistoryLimit indicates the maximum quantity of stored revisions about the SidecarSet. default value is 10",
              "type": "integer",
              "format": "int32"
            },
            "selector": {
              "description": "selector is a label query over pods that should be injected",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "updateStrategy": {
              "description": "The sidecarset updateStrategy to use to replace existing pods with new ones.",
              "type": "object",
              "properties": {
                "maxUnavailable": {
                  "description": "The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.",
                  "x-kubernetes-int-or-string": true
                },
                "partition": {
                  "description": "Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.",
                  "x-kubernetes-int-or-string": true
                },
                "paused": {
                  "description": "Paused indicates that the SidecarSet is paused to update the injected pods, but it don't affect the webhook inject sidecar container into the newly created pods. default is false",
                  "type": "boolean"
                },
                "priorityStrategy": {
                  "description": "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
                  "type": "object",
                  "properties": {
                    "orderPriority": {
                      "description": "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
                      "type": "array",
                      "items": {
                        "description": "UpdatePriorityOrderTerm defines order priority.",
                        "type": "object",
                        "required": [
                          "orderedKey"
                        ],
                        "properties": {
                          "orderedKey": {
                            "description": "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "weightPriority": {
                      "description": "Weight priority terms, pods will be sorted by the sum of all terms weight.",
                      "type": "array",
                      "items": {
                        "description": "UpdatePriorityWeightTerm defines weight priority.",
                        "type": "object",
                        "required": [
                          "matchSelector",
                          "weight"
                        ],
                        "properties": {
                          "matchSelector": {
                            "description": "MatchSelector is used to select by pod's labels.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "weight": {
                            "description": "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      }
                    }
                  }
                },
                "scatterStrategy": {
                  "description": "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "key",
                      "value"
                    ],
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  }
                },
                "selector": {
                  "description": "If selector is not nil, this upgrade will only update the selected pods.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string"
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "type": {
                  "description": "Type is NotUpdate, the SidecarSet don't update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate",
                  "type": "string"
                }
              }
            },
            "volumes": {
              "description": "List of volumes that can be mounted by sidecar containers",
              "x-kubernetes-preserve-unknown-fields": true
            }
          }
        },
        "status": {
          "description": "SidecarSetStatus defines the observed state of SidecarSet",
          "type": "object",
          "required": [
            "matchedPods",
            "readyPods",
            "updatedPods"
          ],
          "properties": {
            "collisionCount": {
              "description": "CollisionCount is the count of hash collisions for the SidecarSet. The SidecarSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
              "type": "integer",
              "format": "int32"
            },
            "latestRevision": {
              "description": "LatestRevision, if not empty, indicates the latest controllerRevision name of the SidecarSet.",
              "type": "string"
            },
            "matchedPods": {
              "description": "matchedPods is the number of Pods whose labels are matched with this SidecarSet's selector and are created after sidecarset creates",
              "type": "integer",
              "format": "int32"
            },
            "observedGeneration": {
              "description": "observedGeneration is the most recent generation observed for this SidecarSet. It corresponds to the SidecarSet's generation, which is updated on mutation by the API Server.",
              "type": "integer",
              "format": "int64"
            },
            "readyPods": {
              "description": "readyPods is the number of matched Pods that have a ready condition",
              "type": "integer",
              "format": "int32"
            },
            "updatedPods": {
              "description": "updatedPods is the number of matched Pods that are injected with the latest SidecarSet's containers",
              "type": "integer",
              "format": "int32"
            },
            "updatedReadyPods": {
              "description": "updatedReadyPods is the number of matched pods that updated and ready",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "SidecarSet",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.NodeImage": {
      "description": "NodeImage is the Schema for the nodeimages API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "NodeImageSpec defines the desired state of NodeImage",
          "type": "object",
          "properties": {
            "images": {
              "description": "Specifies images to be pulled on this node It can not be more than 256 for each NodeImage",
              "type": "object",
              "additionalProperties": {
                "description": "ImageSpec defines the pulling spec of an image",
                "type": "object",
                "required": [
                  "tags"
                ],
                "properties": {
                  "pullSecrets": {
                    "description": "PullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
                    "type": "array",
                    "items": {
                      "description": "ReferenceObject comprises a resource name, with a mandatory namespace, rendered as \"<namespace>/<name>\".",
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string"
                        },
                        "namespace": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "sandboxConfig": {
                    "description": "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
                    "type": "object",
                    "properties": {
                      "annotations": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "labels": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "tags": {
                    "description": "Tags is a list of versions of this image",
                    "type": "array",
                    "items": {
                      "description": "ImageTagSpec defines the pulling spec of an image tag",
                      "type": "object",
                      "required": [
                        "tag"
                      ],
                      "properties": {
                        "createdAt": {
                          "description": "Specifies the create time of this tag",
                          "type": "string",
                          "format": "date-time"
                        },
                        "ownerReferences": {
                          "description": "List of objects depended by this object. If this image is managed by a controller, then an entry in this list will point to this controller.",
                          "type": "array",
                          "items": {
                            "description": "ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, \"must refer only to types A and B\" or \"UID not honored\" or \"name must be restricted\".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .",
                            "type": "object",
                            "properties": {
                              "apiVersion": {
                                "description": "API version of the referent.",
                                "type": "string"
                              },
                              "fieldPath": {
                                "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                                "type": "string"
                              },
                              "kind": {
                                "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                "type": "string"
                              },
                              "resourceVersion": {
                                "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                                "type": "string"
                              },
                              "uid": {
                                "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "pullPolicy": {
                          "description": "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
                          "type": "object",
                          "properties": {
                            "activeDeadlineSeconds": {
                              "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the task may be active before the system tries to terminate it; value must be positive integer. if not specified, the system will never terminate it.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "backoffLimit": {
                              "description": "Specifies the number of retries before marking the pulling task failed. Defaults to 3",
                              "type": "integer",
                              "format": "int32"
                            },
                            "timeoutSeconds": {
                              "description": "Specifies the timeout of the pulling task. Defaults to 600",
                              "type": "integer",
                              "format": "int32"
                            },
                            "ttlSecondsAfterFinished": {
                              "description": "TTLSecondsAfterFinished limits the lifetime of a pulling task that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the task finishes, it is eligible to be automatically deleted. If this field is unset, the task won't be automatically deleted. If this field is set to zero, the task becomes eligible to be deleted immediately after it finishes.",
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        },
                        "tag": {
                          "description": "Specifies the image tag",
                          "type": "string"
                        },
                        "version": {
                          "description": "An opaque value that represents the internal version of this tag that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. \n Populated by the system. Read-only. Value must be treated as opaque by clients and .",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "description": "NodeImageStatus defines the observed state of NodeImage",
          "type": "object",
          "required": [
            "desired"
          ],
          "properties": {
            "desired": {
              "description": "The desired number of pulling tasks, this is typically equal to the number of images in spec.",
              "type": "integer",
              "format": "int32"
            },
            "failed": {
              "description": "The number of pulling tasks  which reached phase Failed.",
              "type": "integer",
              "format": "int32"
            },
            "firstSyncStatus": {
              "description": "The first of all job has finished on this node. When a node is added to the cluster, we want to know the time when the node's image pulling is completed, and use it to trigger the operation of the upper system.",
              "type": "object",
              "properties": {
                "message": {
                  "type": "string"
                },
                "status": {
                  "description": "SyncStatusPhase defines the node status",
                  "type": "string"
                },
                "syncAt": {
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "imageStatuses": {
              "description": "all statuses of active image pulling tasks",
              "type": "object",
              "additionalProperties": {
                "description": "ImageStatus defines the pulling status of an image",
                "type": "object",
                "required": [
                  "tags"
                ],
                "properties": {
                  "tags": {
                    "description": "Represents statuses of pulling tasks on this node",
                    "type": "array",
                    "items": {
                      "description": "ImageTagStatus defines the pulling status of an image tag",
                      "type": "object",
                      "required": [
                        "phase",
                        "tag"
                      ],
                      "properties": {
                        "completionTime": {
                          "description": "Represents time when the pulling task was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
                          "type": "string",
                          "format": "date-time"
                        },
                        "imageID": {
                          "description": "Represents the ID of this image.",
                          "type": "string"
                        },
                        "message": {
                          "description": "Represents the summary information of this node",
                          "type": "string"
                        },
                        "phase": {
                          "description": "Represents the image pulling task phase.",
                          "type": "string"
                        },
                        "progress": {
                          "description": "Represents the pulling progress of this tag, which is between 0-100. There is no guarantee of monotonic consistency, and it may be a rollback due to retry during pulling.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "startTime": {
                          "description": "Represents time when the pulling task was acknowledged by the image puller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
                          "type": "string",
                          "format": "date-time"
                        },
                        "tag": {
                          "description": "Represents the image tag.",
                          "type": "string"
                        },
                        "version": {
                          "description": "Represents the internal version of this tag that the daemon handled.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    }
                  }
                }
              }
            },
            "pulling": {
              "description": "The number of pulling tasks which are not finished.",
              "type": "integer",
              "format": "int32"
            },
            "succeeded": {
              "description": "The number of pulling tasks which reached phase Succeeded.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "NodeImage",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.SidecarSetList": {
      "description": "SidecarSetList is a list of SidecarSet",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of sidecarsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.SidecarSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "SidecarSetList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.ContainerRecreateRequest": {
      "description": "ContainerRecreateRequest is the Schema for the containerrecreaterequests API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "ContainerRecreateRequestSpec defines the desired state of ContainerRecreateRequest",
          "type": "object",
          "required": [
            "containers",
            "podName"
          ],
          "properties": {
            "activeDeadlineSeconds": {
              "description": "ActiveDeadlineSeconds is the deadline duration of this ContainerRecreateRequest.",
              "type": "integer",
              "format": "int64"
            },
            "containers": {
              "description": "Containers contains the containers that need to recreate in the Pod.",
              "type": "array",
              "items": {
                "description": "ContainerRecreateRequestContainer defines the container that need to recreate.",
                "type": "object",
                "required": [
                  "name"
                ],
                "properties": {
                  "name": {
                    "description": "Name of the container that need to recreate. It must be existing in the real pod.Spec.Containers.",
                    "type": "string"
                  },
                  "ports": {
                    "description": "Ports is synced from the real container in Pod spec during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
                    "type": "array",
                    "items": {
                      "description": "ContainerPort represents a network port in a single container.",
                      "type": "object",
                      "required": [
                        "containerPort"
                      ],
                      "properties": {
                        "containerPort": {
                          "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "hostIP": {
                          "description": "What host IP to bind the external port to.",
                          "type": "string"
                        },
                        "hostPort": {
                          "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "name": {
                          "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                          "type": "string"
                        },
                        "protocol": {
                          "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "preStop": {
                    "description": "PreStop is synced from the real container in Pod spec during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
                    "type": "object",
                    "properties": {
                      "exec": {
                        "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                        "type": "object",
                        "properties": {
                          "command": {
                            "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "httpGet": {
                        "description": "HTTPGet specifies the http request to perform.",
                        "type": "object",
                        "required": [
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                            "type": "string"
                          },
                          "httpHeaders": {
                            "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                            "type": "array",
                            "items": {
                              "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                              "type": "object",
                              "required": [
                                "name",
                                "value"
                              ],
                              "properties": {
                                "name": {
                                  "description": "The header field name",
                                  "type": "string"
                                },
                                "value": {
                                  "description": "The header field value",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "path": {
                            "description": "Path to access on the HTTP server.",
                            "type": "string"
                          },
                          "port": {
                            "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                            "x-kubernetes-int-or-string": true
                          },
                          "scheme": {
                            "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                            "type": "string"
                          }
                        }
                      },
                      "tcpSocket": {
                        "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                        "type": "object",
                        "required": [
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "description": "Optional: Host name to connect to, defaults to the pod IP.",
                            "type": "string"
                          },
                          "port": {
                            "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      }
                    }
                  },
                  "statusContext": {
                    "description": "StatusContext is synced from the real Pod status during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
                    "type": "object",
                    "required": [
                      "containerID",
                      "restartCount"
                    ],
                    "properties": {
                      "containerID": {
                        "description": "Container's ID in the format 'docker://<container_id>'.",
                        "type": "string"
                      },
                      "restartCount": {
                        "description": "The number of times the container has been restarted, currently based on the number of dead containers that have not yet been removed. Note that this is calculated from dead containers. But those containers are subject to garbage collection. This value will get capped at 5 by GC.",
                        "type": "integer",
                        "format": "int32"
                      }
                    }
                  }
                }
              }
            },
            "podName": {
              "description": "PodName is name of the Pod that owns the recreated containers.",
              "type": "string"
            },
            "strategy": {
              "description": "Strategy defines strategies for containers recreation.",
              "type": "object",
              "properties": {
                "failurePolicy": {
                  "description": "FailurePolicy decides whether to continue if one container fails to recreate",
                  "type": "string"
                },
                "forceRecreate": {
                  "description": "ForceRecreate indicates whether to force kill the container even if the previous container is starting.",
                  "type": "boolean"
                },
                "minStartedSeconds": {
                  "description": "Minimum number of seconds for which a newly created container should be started and ready without any of its container crashing, for it to be considered Succeeded. Defaults to 0 (container will be considered Succeeded as soon as it is started and ready)",
                  "type": "integer",
                  "format": "int32"
                },
                "orderedRecreate": {
                  "description": "OrderedRecreate indicates whether to recreate the next container only if the previous one has recreated completely.",
                  "type": "boolean"
                },
                "terminationGracePeriodSeconds": {
                  "description": "TerminationGracePeriodSeconds is the optional duration in seconds to wait the container terminating gracefully. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, we will use pod.Spec.TerminationGracePeriodSeconds as default value.",
                  "type": "integer",
                  "format": "int64"
                },
                "unreadyGracePeriodSeconds": {
                  "description": "UnreadyGracePeriodSeconds is the optional duration in seconds to mark Pod as not ready over this duration before executing preStop hook and stopping the container.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "ttlSecondsAfterFinished": {
              "description": "TTLSecondsAfterFinished is the TTL duration after this ContainerRecreateRequest has completed.",
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "status": {
          "description": "ContainerRecreateRequestStatus defines the observed state of ContainerRecreateRequest",
          "type": "object",
          "required": [
            "phase"
          ],
          "properties": {
            "completionTime": {
              "description": "Represents time when the ContainerRecreateRequest was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "containerRecreateStates": {
              "description": "ContainerRecreateStates contains the recreation states of the containers.",
              "type": "array",
              "items": {
                "description": "ContainerRecreateRequestContainerRecreateState contains the recreation state of the container.",
                "type": "object",
                "required": [
                  "name",
                  "phase"
                ],
                "properties": {
                  "isKilled": {
                    "description": "Containers are killed by kruise daemon",
                    "type": "boolean"
                  },
                  "message": {
                    "description": "A human readable message indicating details about this state.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the container.",
                    "type": "string"
                  },
                  "phase": {
                    "description": "Phase indicates the recreation phase of the container.",
                    "type": "string"
                  }
                }
              }
            },
            "message": {
              "description": "A human readable message indicating details about this ContainerRecreateRequest.",
              "type": "string"
            },
            "phase": {
              "description": "Phase of this ContainerRecreateRequest, e.g. Pending, Recreating, Completed",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ContainerRecreateRequest",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.EphemeralJob": {
      "description": "EphemeralJob is the Schema for the ephemeraljobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "EphemeralJobSpec defines the desired state of EphemeralJob",
          "type": "object",
          "required": [
            "selector",
            "template"
          ],
          "properties": {
            "activeDeadlineSeconds": {
              "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
              "type": "integer",
              "format": "int64"
            },
            "parallelism": {
              "description": "Parallelism specifies the maximum desired number of pods which matches running ephemeral containers.",
              "type": "integer",
              "format": "int32"
            },
            "paused": {
              "description": "Paused will pause the ephemeral job.",
              "type": "boolean"
            },
            "replicas": {
              "description": "Replicas indicates a part of the quantity from matched pods by selector. Usually it is used for gray scale working. if Replicas exceeded the matched number by selector or not be set, replicas will not work.",
              "type": "integer",
              "format": "int32"
            },
            "selector": {
              "description": "INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run \"make\" to regenerate code after modifying this file Selector is a label query over pods that should match the pod labels.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "template": {
              "description": "Template describes the ephemeral container that will be created.",
              "type": "object",
              "required": [
                "ephemeralContainers"
              ],
              "properties": {
                "ephemeralContainers": {
                  "description": "EphemeralContainers defines ephemeral container list in match pods.",
                  "x-kubernetes-preserve-unknown-fields": true
                }
              }
            },
            "ttlSecondsAfterFinished": {
              "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the eJob finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, default value is 1800 If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.",
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "status": {
          "description": "EphemeralJobStatus defines the observed state of EphemeralJob",
          "type": "object",
          "properties": {
            "completionTime": {
              "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "conditions": {
              "description": "INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run \"make\" to regenerate code after modifying this file",
              "type": "array",
              "items": {
                "description": "JobCondition describes current state of a job.",
                "type": "object",
                "required": [
                  "status",
                  "type"
                ],
                "properties": {
                  "lastProbeTime": {
                    "description": "Last time the condition was checked.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "lastTransitionTime": {
                    "description": "Last time the condition transit from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "Human readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "(brief) reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of job condition, Complete or Failed.",
                    "type": "string"
                  }
                }
              }
            },
            "failed": {
              "description": "The number of pods which reached phase Failed.",
              "type": "integer",
              "format": "int32"
            },
            "match": {
              "description": "The number of total matched pods.",
              "type": "integer",
              "format": "int32"
            },
            "phase": {
              "description": "The phase of the job.",
              "type": "string"
            },
            "running": {
              "description": "The number of actively running pods.",
              "type": "integer",
              "format": "int32"
            },
            "startTime": {
              "description": "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "succeeded": {
              "description": "The number of pods which reached phase Succeeded.",
              "type": "integer",
              "format": "int32"
            },
            "waiting": {
              "description": "The number of waiting pods.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "EphemeralJob",
          "version": "v1alpha1"
        }
      ]
    },
    "v1alpha1.ResourceDistributionList": {
      "description": "ResourceDistributionList is a list of ResourceDistribution",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "description": "List of resourcedistributions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1.ResourceDistribution"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ResourceDistributionList",
          "version": "v1alpha1"
        }
      ],
      "x-implements": [
        "io.kubernetes.client.common.KubernetesListObject"
      ]
    },
    "v1alpha1.ImagePullJob": {
      "description": "ImagePullJob is the Schema for the imagepulljobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "spec": {
          "description": "ImagePullJobSpec defines the desired state of ImagePullJob",
          "type": "object",
          "required": [
            "completionPolicy",
            "image"
          ],
          "properties": {
            "completionPolicy": {
              "description": "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
              "type": "object",
              "properties": {
                "activeDeadlineSeconds": {
                  "description": "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
                  "type": "integer",
                  "format": "int64"
                },
                "ttlSecondsAfterFinished": {
                  "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Only works for Always type",
                  "type": "integer",
                  "format": "int32"
                },
                "type": {
                  "description": "Type indicates the type of the CompletionPolicy. Default is Always.",
                  "type": "string"
                }
              }
            },
            "image": {
              "description": "Image is the image to be pulled by the job",
              "type": "string"
            },
            "parallelism": {
              "description": "Parallelism is the requested parallelism, it can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.",
              "x-kubernetes-int-or-string": true
            },
            "podSelector": {
              "description": "PodSelector is a query over pods that should pull image on nodes of these pods. Mutually exclusive with Selector.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "pullPolicy": {
              "description": "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
              "type": "object",
              "properties": {
                "backoffLimit": {
                  "description": "Specifies the number of retries before marking the pulling task failed. Defaults to 3",
                  "type": "integer",
                  "format": "int32"
                },
                "timeoutSeconds": {
                  "description": "Specifies the timeout of the pulling task. Defaults to 600",
                  "type": "integer",
                  "format": "int32"
                }
              }
            },
            "pullSecrets": {
              "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "sandboxConfig": {
              "description": "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
              "type": "object",
              "properties": {
                "annotations": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "selector": {
              "description": "Selector is a query over nodes that should match the job. nil to match all nodes.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": [
                      "key",
                      "operator"
                    ],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "names": {
                  "description": "Names specify a set of nodes to execute the job.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "description": "ImagePullJobStatus defines the observed state of ImagePullJob",
          "type": "object",
          "required": [
            "desired"
          ],
          "properties": {
            "active": {
              "description": "The number of actively running pulling tasks.",
              "type": "integer",
              "format": "int32"
            },
            "completionTime": {
              "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "desired": {
              "description": "The desired number of pulling tasks, this is typically equal to the number of nodes satisfied.",
              "type": "integer",
              "format": "int32"
            },
            "failed": {
              "description": "The number of pulling tasks  which reached phase Failed.",
              "type": "integer",
              "format": "int32"
            },
            "failedNodes": {
              "description": "The nodes that failed to pull the image.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "message": {
              "description": "The text prompt for job running status.",
              "type": "string"
            },
            "startTime": {
              "description": "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
              "type": "string",
              "format": "date-time"
            },
            "succeeded": {
              "description": "The number of pulling tasks which reached phase Succeeded.",
              "type": "integer",
              "format": "int32"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps.kruise.io",
          "kind": "ImagePullJob",
          "version": "v1alpha1"
        }
      ]
    }
  },
  "securityDefinitions": {
    "BearerToken": {
      "description": "Bearer Token authentication",
      "type": "apiKey",
      "name": "authorization",
      "in": "header"
    }
  },
  "security": [
    {
      "BearerToken": []
    }
  ]
}